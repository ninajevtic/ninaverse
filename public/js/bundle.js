/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./public/js/main.js":
/*!***************************!*\
  !*** ./public/js/main.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var mdb_ui_kit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mdb-ui-kit */ \"./node_modules/mdb-ui-kit/js/mdb.es.min.js\");\n// Initialization for ES Users\r\n\r\n\r\n(0,mdb_ui_kit__WEBPACK_IMPORTED_MODULE_0__.initMDB)({ Collapse: mdb_ui_kit__WEBPACK_IMPORTED_MODULE_0__.Collapse });\n\n//# sourceURL=webpack://ninaverse/./public/js/main.js?");

/***/ }),

/***/ "./node_modules/mdb-ui-kit/js/mdb.es.min.js":
/*!**************************************************!*\
  !*** ./node_modules/mdb-ui-kit/js/mdb.es.min.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Alert: () => (/* binding */ Alert2),\n/* harmony export */   Button: () => (/* binding */ Button2),\n/* harmony export */   Carousel: () => (/* binding */ Carousel2),\n/* harmony export */   Collapse: () => (/* binding */ Collapse2),\n/* harmony export */   Dropdown: () => (/* binding */ Dropdown2),\n/* harmony export */   Input: () => (/* binding */ Input),\n/* harmony export */   Modal: () => (/* binding */ Modal2),\n/* harmony export */   Offcanvas: () => (/* binding */ Offcanvas),\n/* harmony export */   Popover: () => (/* binding */ Popover2),\n/* harmony export */   Range: () => (/* binding */ Range),\n/* harmony export */   Ripple: () => (/* binding */ Ripple),\n/* harmony export */   ScrollSpy: () => (/* binding */ ScrollSpy2),\n/* harmony export */   Tab: () => (/* binding */ Tab2),\n/* harmony export */   Toast: () => (/* binding */ Toast2),\n/* harmony export */   Tooltip: () => (/* binding */ Tooltip2),\n/* harmony export */   initMDB: () => (/* binding */ initMDB)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst mapData = (() => {\n  const storeData = {};\n  let id = 1;\n  return {\n    set(element2, key, data) {\n      if (typeof element2[key] === \"undefined\") {\n        element2[key] = {\n          key,\n          id\n        };\n        id++;\n      }\n      storeData[element2[key].id] = data;\n    },\n    get(element2, key) {\n      if (!element2 || typeof element2[key] === \"undefined\") {\n        return null;\n      }\n      const keyProperties = element2[key];\n      if (keyProperties.key === key) {\n        return storeData[keyProperties.id];\n      }\n      return null;\n    },\n    delete(element2, key) {\n      if (typeof element2[key] === \"undefined\") {\n        return;\n      }\n      const keyProperties = element2[key];\n      if (keyProperties.key === key) {\n        delete storeData[keyProperties.id];\n        delete element2[key];\n      }\n    }\n  };\n})();\nconst Data$1 = {\n  setData(instance, key, data) {\n    mapData.set(instance, key, data);\n  },\n  getData(instance, key) {\n    return mapData.get(instance, key);\n  },\n  removeData(instance, key) {\n    mapData.delete(instance, key);\n  }\n};\nconst toType$1 = (obj) => {\n  if (obj === null || obj === void 0) {\n    return `${obj}`;\n  }\n  return {}.toString.call(obj).match(/\\s([a-z]+)/i)[1].toLowerCase();\n};\nconst getSelector$1 = (element2) => {\n  let selector = element2.getAttribute(\"data-mdb-target\");\n  if (!selector || selector === \"#\") {\n    const hrefAttr = element2.getAttribute(\"href\");\n    selector = hrefAttr && hrefAttr !== \"#\" ? hrefAttr.trim() : null;\n  }\n  return selector;\n};\nconst getSelectorFromElement = (element2) => {\n  const selector = getSelector$1(element2);\n  if (selector) {\n    return document.querySelector(selector) ? selector : null;\n  }\n  return null;\n};\nconst getElementFromSelector = (element2) => {\n  const selector = getSelector$1(element2);\n  return selector ? document.querySelector(selector) : null;\n};\nconst isElement$2 = (obj) => {\n  if (!obj || typeof obj !== \"object\") {\n    return false;\n  }\n  if (typeof obj.jquery !== \"undefined\") {\n    obj = obj[0];\n  }\n  return typeof obj.nodeType !== \"undefined\";\n};\nconst getElement$1 = (obj) => {\n  if (isElement$2(obj)) {\n    return obj.jquery ? obj[0] : obj;\n  }\n  if (typeof obj === \"string\" && obj.length > 0) {\n    return document.querySelector(obj);\n  }\n  return null;\n};\nconst typeCheckConfig = (componentName, config, configTypes) => {\n  Object.keys(configTypes).forEach((property) => {\n    const expectedTypes = configTypes[property];\n    const value = config[property];\n    const valueType = value && isElement$2(value) ? \"element\" : toType$1(value);\n    if (!new RegExp(expectedTypes).test(valueType)) {\n      throw new Error(\n        `${componentName.toUpperCase()}: Option \"${property}\" provided type \"${valueType}\" but expected type \"${expectedTypes}\".`\n      );\n    }\n  });\n};\nconst isVisible$1 = (element2) => {\n  if (!element2) {\n    return false;\n  }\n  if (element2.style && element2.parentNode && element2.parentNode.style) {\n    const elementStyle = getComputedStyle(element2);\n    const parentNodeStyle = getComputedStyle(element2.parentNode);\n    return elementStyle.display !== \"none\" && parentNodeStyle.display !== \"none\" && elementStyle.visibility !== \"hidden\";\n  }\n  return false;\n};\nconst isDisabled$1 = (element2) => {\n  if (!element2 || element2.nodeType !== Node.ELEMENT_NODE) {\n    return true;\n  }\n  if (element2.classList.contains(\"disabled\")) {\n    return true;\n  }\n  if (typeof element2.disabled !== \"undefined\") {\n    return element2.disabled;\n  }\n  return element2.hasAttribute(\"disabled\") && element2.getAttribute(\"disabled\") !== \"false\";\n};\nconst getjQuery$1 = () => {\n  const { jQuery } = window;\n  if (jQuery && !document.body.hasAttribute(\"data-mdb-no-jquery\")) {\n    return jQuery;\n  }\n  return null;\n};\nconst onDOMContentLoaded = (callback) => {\n  if (document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", callback);\n  } else {\n    callback();\n  }\n};\ndocument.documentElement.dir === \"rtl\";\nconst element = (tag) => {\n  return document.createElement(tag);\n};\nconst defineJQueryPlugin = (plugin) => {\n  onDOMContentLoaded(() => {\n    const $2 = getjQuery$1();\n    if ($2) {\n      const name = plugin.NAME;\n      const JQUERY_NO_CONFLICT = $2.fn[name];\n      $2.fn[name] = plugin.jQueryInterface;\n      $2.fn[name].Constructor = plugin;\n      $2.fn[name].noConflict = () => {\n        $2.fn[name] = JQUERY_NO_CONFLICT;\n        return plugin.jQueryInterface;\n      };\n    }\n  });\n};\nconst $ = getjQuery$1();\nconst namespaceRegex$1 = /[^.]*(?=\\..*)\\.|.*/;\nconst stripNameRegex$1 = /\\..*/;\nconst stripUidRegex$1 = /::\\d+$/;\nconst eventRegistry$1 = {};\nlet uidEvent$1 = 1;\nconst customEvents$1 = {\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n};\nconst nativeEvents$1 = [\n  \"click\",\n  \"dblclick\",\n  \"mouseup\",\n  \"mousedown\",\n  \"contextmenu\",\n  \"mousewheel\",\n  \"DOMMouseScroll\",\n  \"mouseover\",\n  \"mouseout\",\n  \"mousemove\",\n  \"selectstart\",\n  \"selectend\",\n  \"keydown\",\n  \"keypress\",\n  \"keyup\",\n  \"orientationchange\",\n  \"touchstart\",\n  \"touchmove\",\n  \"touchend\",\n  \"touchcancel\",\n  \"pointerdown\",\n  \"pointermove\",\n  \"pointerup\",\n  \"pointerleave\",\n  \"pointercancel\",\n  \"gesturestart\",\n  \"gesturechange\",\n  \"gestureend\",\n  \"focus\",\n  \"blur\",\n  \"change\",\n  \"reset\",\n  \"select\",\n  \"submit\",\n  \"focusin\",\n  \"focusout\",\n  \"load\",\n  \"unload\",\n  \"beforeunload\",\n  \"resize\",\n  \"move\",\n  \"DOMContentLoaded\",\n  \"readystatechange\",\n  \"error\",\n  \"abort\",\n  \"scroll\"\n];\nfunction getUidEvent(element2, uid) {\n  return uid && `${uid}::${uidEvent$1++}` || element2.uidEvent || uidEvent$1++;\n}\nfunction getEvent(element2) {\n  const uid = getUidEvent(element2);\n  element2.uidEvent = uid;\n  eventRegistry$1[uid] = eventRegistry$1[uid] || {};\n  return eventRegistry$1[uid];\n}\nfunction bootstrapHandler$1(element2, fn2) {\n  return function handler(event) {\n    event.delegateTarget = element2;\n    if (handler.oneOff) {\n      EventHandler$1.off(element2, event.type, fn2);\n    }\n    return fn2.apply(element2, [event]);\n  };\n}\nfunction bootstrapDelegationHandler$1(element2, selector, fn2) {\n  return function handler(event) {\n    const domElements = element2.querySelectorAll(selector);\n    for (let { target } = event; target && target !== this; target = target.parentNode) {\n      for (let i = domElements.length; i--; \"\") {\n        if (domElements[i] === target) {\n          event.delegateTarget = target;\n          if (handler.oneOff) {\n            EventHandler$1.off(element2, event.type, fn2);\n          }\n          return fn2.apply(target, [event]);\n        }\n      }\n    }\n    return null;\n  };\n}\nfunction findHandler$1(events, handler, delegationSelector = null) {\n  const uidEventList = Object.keys(events);\n  for (let i = 0, len = uidEventList.length; i < len; i++) {\n    const event = events[uidEventList[i]];\n    if (event.originalHandler === handler && event.delegationSelector === delegationSelector) {\n      return event;\n    }\n  }\n  return null;\n}\nfunction normalizeParams(originalTypeEvent, handler, delegationFn) {\n  const delegation = typeof handler === \"string\";\n  const originalHandler = delegation ? delegationFn : handler;\n  let typeEvent = originalTypeEvent.replace(stripNameRegex$1, \"\");\n  const custom = customEvents$1[typeEvent];\n  if (custom) {\n    typeEvent = custom;\n  }\n  const isNative = nativeEvents$1.indexOf(typeEvent) > -1;\n  if (!isNative) {\n    typeEvent = originalTypeEvent;\n  }\n  return [delegation, originalHandler, typeEvent];\n}\nfunction addHandler$1(element2, originalTypeEvent, handler, delegationFn, oneOff) {\n  if (typeof originalTypeEvent !== \"string\" || !element2) {\n    return;\n  }\n  if (!handler) {\n    handler = delegationFn;\n    delegationFn = null;\n  }\n  const [delegation, originalHandler, typeEvent] = normalizeParams(\n    originalTypeEvent,\n    handler,\n    delegationFn\n  );\n  const events = getEvent(element2);\n  const handlers = events[typeEvent] || (events[typeEvent] = {});\n  const previousFn = findHandler$1(handlers, originalHandler, delegation ? handler : null);\n  if (previousFn) {\n    previousFn.oneOff = previousFn.oneOff && oneOff;\n    return;\n  }\n  const uid = getUidEvent(originalHandler, originalTypeEvent.replace(namespaceRegex$1, \"\"));\n  const fn2 = delegation ? bootstrapDelegationHandler$1(element2, handler, delegationFn) : bootstrapHandler$1(element2, handler);\n  fn2.delegationSelector = delegation ? handler : null;\n  fn2.originalHandler = originalHandler;\n  fn2.oneOff = oneOff;\n  fn2.uidEvent = uid;\n  handlers[uid] = fn2;\n  element2.addEventListener(typeEvent, fn2, delegation);\n}\nfunction removeHandler$1(element2, events, typeEvent, handler, delegationSelector) {\n  const fn2 = findHandler$1(events[typeEvent], handler, delegationSelector);\n  if (!fn2) {\n    return;\n  }\n  element2.removeEventListener(typeEvent, fn2, Boolean(delegationSelector));\n  delete events[typeEvent][fn2.uidEvent];\n}\nfunction removeNamespacedHandlers$1(element2, events, typeEvent, namespace) {\n  const storeElementEvent = events[typeEvent] || {};\n  Object.keys(storeElementEvent).forEach((handlerKey) => {\n    if (handlerKey.indexOf(namespace) > -1) {\n      const event = storeElementEvent[handlerKey];\n      removeHandler$1(element2, events, typeEvent, event.originalHandler, event.delegationSelector);\n    }\n  });\n}\nconst EventHandler$1 = {\n  on(element2, event, handler, delegationFn) {\n    addHandler$1(element2, event, handler, delegationFn, false);\n  },\n  one(element2, event, handler, delegationFn) {\n    addHandler$1(element2, event, handler, delegationFn, true);\n  },\n  extend(element2, events, componentName) {\n    events.forEach((event) => {\n      EventHandler$1.on(element2, `${event.name}.bs.${componentName}`, (e) => {\n        const eventParameters = {};\n        if (event.parametersToCopy) {\n          event.parametersToCopy.forEach((param) => {\n            eventParameters[param] = e[param];\n          });\n        }\n        const mdbEvent = EventHandler$1.trigger(\n          element2,\n          `${event.name}.mdb.${componentName}`,\n          eventParameters\n        );\n        if (mdbEvent.defaultPrevented) {\n          e.preventDefault();\n        }\n      });\n    });\n  },\n  off(element2, originalTypeEvent, handler, delegationFn) {\n    if (typeof originalTypeEvent !== \"string\" || !element2) {\n      return;\n    }\n    const [delegation, originalHandler, typeEvent] = normalizeParams(\n      originalTypeEvent,\n      handler,\n      delegationFn\n    );\n    const inNamespace = typeEvent !== originalTypeEvent;\n    const events = getEvent(element2);\n    const isNamespace = originalTypeEvent.charAt(0) === \".\";\n    if (typeof originalHandler !== \"undefined\") {\n      if (!events || !events[typeEvent]) {\n        return;\n      }\n      removeHandler$1(element2, events, typeEvent, originalHandler, delegation ? handler : null);\n      return;\n    }\n    if (isNamespace) {\n      Object.keys(events).forEach((elementEvent) => {\n        removeNamespacedHandlers$1(element2, events, elementEvent, originalTypeEvent.slice(1));\n      });\n    }\n    const storeElementEvent = events[typeEvent] || {};\n    Object.keys(storeElementEvent).forEach((keyHandlers) => {\n      const handlerKey = keyHandlers.replace(stripUidRegex$1, \"\");\n      if (!inNamespace || originalTypeEvent.indexOf(handlerKey) > -1) {\n        const event = storeElementEvent[keyHandlers];\n        removeHandler$1(element2, events, typeEvent, event.originalHandler, event.delegationSelector);\n      }\n    });\n  },\n  trigger(element2, event, args) {\n    if (typeof event !== \"string\" || !element2) {\n      return null;\n    }\n    const typeEvent = event.replace(stripNameRegex$1, \"\");\n    const inNamespace = event !== typeEvent;\n    const isNative = nativeEvents$1.indexOf(typeEvent) > -1;\n    let jQueryEvent;\n    let bubbles = true;\n    let nativeDispatch = true;\n    let defaultPrevented = false;\n    let evt = null;\n    if (inNamespace && $) {\n      jQueryEvent = $.Event(event, args);\n      $(element2).trigger(jQueryEvent);\n      bubbles = !jQueryEvent.isPropagationStopped();\n      nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();\n      defaultPrevented = jQueryEvent.isDefaultPrevented();\n    }\n    if (isNative) {\n      evt = document.createEvent(\"HTMLEvents\");\n      evt.initEvent(typeEvent, bubbles, true);\n    } else {\n      evt = new CustomEvent(event, {\n        bubbles,\n        cancelable: true\n      });\n    }\n    if (typeof args !== \"undefined\") {\n      Object.keys(args).forEach((key) => {\n        Object.defineProperty(evt, key, {\n          get() {\n            return args[key];\n          }\n        });\n      });\n    }\n    if (defaultPrevented) {\n      evt.preventDefault();\n    }\n    if (nativeDispatch) {\n      element2.dispatchEvent(evt);\n    }\n    if (evt.defaultPrevented && typeof jQueryEvent !== \"undefined\") {\n      jQueryEvent.preventDefault();\n    }\n    return evt;\n  }\n};\nfunction normalizeData$1(val) {\n  if (val === \"true\") {\n    return true;\n  }\n  if (val === \"false\") {\n    return false;\n  }\n  if (val === Number(val).toString()) {\n    return Number(val);\n  }\n  if (val === \"\" || val === \"null\") {\n    return null;\n  }\n  return val;\n}\nfunction normalizeDataKey$1(key) {\n  return key.replace(/[A-Z]/g, (chr) => `-${chr.toLowerCase()}`);\n}\nconst Manipulator$1 = {\n  setDataAttribute(element2, key, value) {\n    element2.setAttribute(`data-mdb-${normalizeDataKey$1(key)}`, value);\n  },\n  removeDataAttribute(element2, key) {\n    element2.removeAttribute(`data-mdb-${normalizeDataKey$1(key)}`);\n  },\n  getDataAttributes(element2) {\n    if (!element2) {\n      return {};\n    }\n    const attributes = {\n      ...element2.dataset\n    };\n    Object.keys(attributes).filter((key) => key.startsWith(\"mdb\")).forEach((key) => {\n      let pureKey = key.replace(/^mdb/, \"\");\n      pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);\n      attributes[pureKey] = normalizeData$1(attributes[key]);\n    });\n    return attributes;\n  },\n  getDataAttribute(element2, key) {\n    return normalizeData$1(element2.getAttribute(`data-mdb-${normalizeDataKey$1(key)}`));\n  },\n  offset(element2) {\n    const rect = element2.getBoundingClientRect();\n    return {\n      top: rect.top + document.body.scrollTop,\n      left: rect.left + document.body.scrollLeft\n    };\n  },\n  position(element2) {\n    return {\n      top: element2.offsetTop,\n      left: element2.offsetLeft\n    };\n  },\n  style(element2, style) {\n    Object.assign(element2.style, style);\n  },\n  toggleClass(element2, className) {\n    if (!element2) {\n      return;\n    }\n    if (element2.classList.contains(className)) {\n      element2.classList.remove(className);\n    } else {\n      element2.classList.add(className);\n    }\n  },\n  addClass(element2, className) {\n    if (element2.classList.contains(className))\n      return;\n    element2.classList.add(className);\n  },\n  addStyle(element2, style) {\n    Object.keys(style).forEach((property) => {\n      element2.style[property] = style[property];\n    });\n  },\n  removeClass(element2, className) {\n    if (!element2.classList.contains(className))\n      return;\n    element2.classList.remove(className);\n  },\n  hasClass(element2, className) {\n    return element2.classList.contains(className);\n  }\n};\nconst NODE_TEXT = 3;\nconst SelectorEngine$1 = {\n  closest(element2, selector) {\n    return element2.closest(selector);\n  },\n  matches(element2, selector) {\n    return element2.matches(selector);\n  },\n  find(selector, element2 = document.documentElement) {\n    return [].concat(...Element.prototype.querySelectorAll.call(element2, selector));\n  },\n  findOne(selector, element2 = document.documentElement) {\n    return Element.prototype.querySelector.call(element2, selector);\n  },\n  children(element2, selector) {\n    const children = [].concat(...element2.children);\n    return children.filter((child) => child.matches(selector));\n  },\n  parents(element2, selector) {\n    const parents = [];\n    let ancestor = element2.parentNode;\n    while (ancestor && ancestor.nodeType === Node.ELEMENT_NODE && ancestor.nodeType !== NODE_TEXT) {\n      if (this.matches(ancestor, selector)) {\n        parents.push(ancestor);\n      }\n      ancestor = ancestor.parentNode;\n    }\n    return parents;\n  },\n  prev(element2, selector) {\n    let previous = element2.previousElementSibling;\n    while (previous) {\n      if (previous.matches(selector)) {\n        return [previous];\n      }\n      previous = previous.previousElementSibling;\n    }\n    return [];\n  },\n  next(element2, selector) {\n    let next = element2.nextElementSibling;\n    while (next) {\n      if (this.matches(next, selector)) {\n        return [next];\n      }\n      next = next.nextElementSibling;\n    }\n    return [];\n  }\n};\nconst elementMap = /* @__PURE__ */ new Map();\nconst Data = {\n  set(element2, key, instance) {\n    if (!elementMap.has(element2)) {\n      elementMap.set(element2, /* @__PURE__ */ new Map());\n    }\n    const instanceMap = elementMap.get(element2);\n    if (!instanceMap.has(key) && instanceMap.size !== 0) {\n      console.error(\n        `Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`\n      );\n      return;\n    }\n    instanceMap.set(key, instance);\n  },\n  get(element2, key) {\n    if (elementMap.has(element2)) {\n      return elementMap.get(element2).get(key) || null;\n    }\n    return null;\n  },\n  remove(element2, key) {\n    if (!elementMap.has(element2)) {\n      return;\n    }\n    const instanceMap = elementMap.get(element2);\n    instanceMap.delete(key);\n    if (instanceMap.size === 0) {\n      elementMap.delete(element2);\n    }\n  }\n};\nconst MAX_UID = 1e6;\nconst MILLISECONDS_MULTIPLIER = 1e3;\nconst TRANSITION_END = \"transitionend\";\nconst parseSelector = (selector) => {\n  if (selector && window.CSS && window.CSS.escape) {\n    selector = selector.replace(/#([^\\s\"#']+)/g, (match, id) => `#${CSS.escape(id)}`);\n  }\n  return selector;\n};\nconst toType = (object) => {\n  if (object === null || object === void 0) {\n    return `${object}`;\n  }\n  return Object.prototype.toString.call(object).match(/\\s([a-z]+)/i)[1].toLowerCase();\n};\nconst getUID = (prefix) => {\n  do {\n    prefix += Math.floor(Math.random() * MAX_UID);\n  } while (document.getElementById(prefix));\n  return prefix;\n};\nconst getTransitionDurationFromElement = (element2) => {\n  if (!element2) {\n    return 0;\n  }\n  let { transitionDuration, transitionDelay } = window.getComputedStyle(element2);\n  const floatTransitionDuration = Number.parseFloat(transitionDuration);\n  const floatTransitionDelay = Number.parseFloat(transitionDelay);\n  if (!floatTransitionDuration && !floatTransitionDelay) {\n    return 0;\n  }\n  transitionDuration = transitionDuration.split(\",\")[0];\n  transitionDelay = transitionDelay.split(\",\")[0];\n  return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;\n};\nconst triggerTransitionEnd = (element2) => {\n  element2.dispatchEvent(new Event(TRANSITION_END));\n};\nconst isElement$1 = (object) => {\n  if (!object || typeof object !== \"object\") {\n    return false;\n  }\n  if (typeof object.jquery !== \"undefined\") {\n    object = object[0];\n  }\n  return typeof object.nodeType !== \"undefined\";\n};\nconst getElement = (object) => {\n  if (isElement$1(object)) {\n    return object.jquery ? object[0] : object;\n  }\n  if (typeof object === \"string\" && object.length > 0) {\n    return document.querySelector(parseSelector(object));\n  }\n  return null;\n};\nconst isVisible = (element2) => {\n  if (!isElement$1(element2) || element2.getClientRects().length === 0) {\n    return false;\n  }\n  const elementIsVisible = getComputedStyle(element2).getPropertyValue(\"visibility\") === \"visible\";\n  const closedDetails = element2.closest(\"details:not([open])\");\n  if (!closedDetails) {\n    return elementIsVisible;\n  }\n  if (closedDetails !== element2) {\n    const summary = element2.closest(\"summary\");\n    if (summary && summary.parentNode !== closedDetails) {\n      return false;\n    }\n    if (summary === null) {\n      return false;\n    }\n  }\n  return elementIsVisible;\n};\nconst isDisabled = (element2) => {\n  if (!element2 || element2.nodeType !== Node.ELEMENT_NODE) {\n    return true;\n  }\n  if (element2.classList.contains(\"disabled\")) {\n    return true;\n  }\n  if (typeof element2.disabled !== \"undefined\") {\n    return element2.disabled;\n  }\n  return element2.hasAttribute(\"disabled\") && element2.getAttribute(\"disabled\") !== \"false\";\n};\nconst findShadowRoot = (element2) => {\n  if (!document.documentElement.attachShadow) {\n    return null;\n  }\n  if (typeof element2.getRootNode === \"function\") {\n    const root = element2.getRootNode();\n    return root instanceof ShadowRoot ? root : null;\n  }\n  if (element2 instanceof ShadowRoot) {\n    return element2;\n  }\n  if (!element2.parentNode) {\n    return null;\n  }\n  return findShadowRoot(element2.parentNode);\n};\nconst noop = () => {\n};\nconst reflow = (element2) => {\n  element2.offsetHeight;\n};\nconst getjQuery = () => {\n  if (window.jQuery && !document.body.hasAttribute(\"data-mdb-no-jquery\")) {\n    return window.jQuery;\n  }\n  return null;\n};\nconst isRTL = () => document.documentElement.dir === \"rtl\";\nconst execute = (possibleCallback, args = [], defaultValue = possibleCallback) => {\n  return typeof possibleCallback === \"function\" ? possibleCallback(...args) : defaultValue;\n};\nconst executeAfterTransition = (callback, transitionElement, waitForTransition = true) => {\n  if (!waitForTransition) {\n    execute(callback);\n    return;\n  }\n  const durationPadding = 5;\n  const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;\n  let called = false;\n  const handler = ({ target }) => {\n    if (target !== transitionElement) {\n      return;\n    }\n    called = true;\n    transitionElement.removeEventListener(TRANSITION_END, handler);\n    execute(callback);\n  };\n  transitionElement.addEventListener(TRANSITION_END, handler);\n  setTimeout(() => {\n    if (!called) {\n      triggerTransitionEnd(transitionElement);\n    }\n  }, emulatedDuration);\n};\nconst getNextActiveElement = (list, activeElement, shouldGetNext, isCycleAllowed) => {\n  const listLength = list.length;\n  let index = list.indexOf(activeElement);\n  if (index === -1) {\n    return !shouldGetNext && isCycleAllowed ? list[listLength - 1] : list[0];\n  }\n  index += shouldGetNext ? 1 : -1;\n  if (isCycleAllowed) {\n    index = (index + listLength) % listLength;\n  }\n  return list[Math.max(0, Math.min(index, listLength - 1))];\n};\nconst namespaceRegex = /[^.]*(?=\\..*)\\.|.*/;\nconst stripNameRegex = /\\..*/;\nconst stripUidRegex = /::\\d+$/;\nconst eventRegistry = {};\nlet uidEvent = 1;\nconst customEvents = {\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n};\nconst nativeEvents = /* @__PURE__ */ new Set([\n  \"click\",\n  \"dblclick\",\n  \"mouseup\",\n  \"mousedown\",\n  \"contextmenu\",\n  \"mousewheel\",\n  \"DOMMouseScroll\",\n  \"mouseover\",\n  \"mouseout\",\n  \"mousemove\",\n  \"selectstart\",\n  \"selectend\",\n  \"keydown\",\n  \"keypress\",\n  \"keyup\",\n  \"orientationchange\",\n  \"touchstart\",\n  \"touchmove\",\n  \"touchend\",\n  \"touchcancel\",\n  \"pointerdown\",\n  \"pointermove\",\n  \"pointerup\",\n  \"pointerleave\",\n  \"pointercancel\",\n  \"gesturestart\",\n  \"gesturechange\",\n  \"gestureend\",\n  \"focus\",\n  \"blur\",\n  \"change\",\n  \"reset\",\n  \"select\",\n  \"submit\",\n  \"focusin\",\n  \"focusout\",\n  \"load\",\n  \"unload\",\n  \"beforeunload\",\n  \"resize\",\n  \"move\",\n  \"DOMContentLoaded\",\n  \"readystatechange\",\n  \"error\",\n  \"abort\",\n  \"scroll\"\n]);\nfunction makeEventUid(element2, uid) {\n  return uid && `${uid}::${uidEvent++}` || element2.uidEvent || uidEvent++;\n}\nfunction getElementEvents(element2) {\n  const uid = makeEventUid(element2);\n  element2.uidEvent = uid;\n  eventRegistry[uid] = eventRegistry[uid] || {};\n  return eventRegistry[uid];\n}\nfunction bootstrapHandler(element2, fn2) {\n  return function handler(event) {\n    hydrateObj(event, { delegateTarget: element2 });\n    if (handler.oneOff) {\n      EventHandler.off(element2, event.type, fn2);\n    }\n    return fn2.apply(element2, [event]);\n  };\n}\nfunction bootstrapDelegationHandler(element2, selector, fn2) {\n  return function handler(event) {\n    const domElements = element2.querySelectorAll(selector);\n    for (let { target } = event; target && target !== this; target = target.parentNode) {\n      for (const domElement of domElements) {\n        if (domElement !== target) {\n          continue;\n        }\n        hydrateObj(event, { delegateTarget: target });\n        if (handler.oneOff) {\n          EventHandler.off(element2, event.type, selector, fn2);\n        }\n        return fn2.apply(target, [event]);\n      }\n    }\n  };\n}\nfunction findHandler(events, callable, delegationSelector = null) {\n  return Object.values(events).find(\n    (event) => event.callable === callable && event.delegationSelector === delegationSelector\n  );\n}\nfunction normalizeParameters(originalTypeEvent, handler, delegationFunction) {\n  const isDelegated = typeof handler === \"string\";\n  const callable = isDelegated ? delegationFunction : handler || delegationFunction;\n  let typeEvent = getTypeEvent(originalTypeEvent);\n  if (!nativeEvents.has(typeEvent)) {\n    typeEvent = originalTypeEvent;\n  }\n  return [isDelegated, callable, typeEvent];\n}\nfunction addHandler(element2, originalTypeEvent, handler, delegationFunction, oneOff) {\n  if (typeof originalTypeEvent !== \"string\" || !element2) {\n    return;\n  }\n  let [isDelegated, callable, typeEvent] = normalizeParameters(\n    originalTypeEvent,\n    handler,\n    delegationFunction\n  );\n  if (originalTypeEvent in customEvents) {\n    const wrapFunction = (fn3) => {\n      return function(event) {\n        if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {\n          return fn3.call(this, event);\n        }\n      };\n    };\n    callable = wrapFunction(callable);\n  }\n  const events = getElementEvents(element2);\n  const handlers = events[typeEvent] || (events[typeEvent] = {});\n  const previousFunction = findHandler(handlers, callable, isDelegated ? handler : null);\n  if (previousFunction) {\n    previousFunction.oneOff = previousFunction.oneOff && oneOff;\n    return;\n  }\n  const uid = makeEventUid(callable, originalTypeEvent.replace(namespaceRegex, \"\"));\n  const fn2 = isDelegated ? bootstrapDelegationHandler(element2, handler, callable) : bootstrapHandler(element2, callable);\n  fn2.delegationSelector = isDelegated ? handler : null;\n  fn2.callable = callable;\n  fn2.oneOff = oneOff;\n  fn2.uidEvent = uid;\n  handlers[uid] = fn2;\n  element2.addEventListener(typeEvent, fn2, isDelegated);\n}\nfunction removeHandler(element2, events, typeEvent, handler, delegationSelector) {\n  const fn2 = findHandler(events[typeEvent], handler, delegationSelector);\n  if (!fn2) {\n    return;\n  }\n  element2.removeEventListener(typeEvent, fn2, Boolean(delegationSelector));\n  delete events[typeEvent][fn2.uidEvent];\n}\nfunction removeNamespacedHandlers(element2, events, typeEvent, namespace) {\n  const storeElementEvent = events[typeEvent] || {};\n  for (const [handlerKey, event] of Object.entries(storeElementEvent)) {\n    if (handlerKey.includes(namespace)) {\n      removeHandler(element2, events, typeEvent, event.callable, event.delegationSelector);\n    }\n  }\n}\nfunction getTypeEvent(event) {\n  event = event.replace(stripNameRegex, \"\");\n  return customEvents[event] || event;\n}\nconst EventHandler = {\n  on(element2, event, handler, delegationFunction) {\n    addHandler(element2, event, handler, delegationFunction, false);\n  },\n  one(element2, event, handler, delegationFunction) {\n    addHandler(element2, event, handler, delegationFunction, true);\n  },\n  off(element2, originalTypeEvent, handler, delegationFunction) {\n    if (typeof originalTypeEvent !== \"string\" || !element2) {\n      return;\n    }\n    const [isDelegated, callable, typeEvent] = normalizeParameters(\n      originalTypeEvent,\n      handler,\n      delegationFunction\n    );\n    const inNamespace = typeEvent !== originalTypeEvent;\n    const events = getElementEvents(element2);\n    const storeElementEvent = events[typeEvent] || {};\n    const isNamespace = originalTypeEvent.startsWith(\".\");\n    if (typeof callable !== \"undefined\") {\n      if (!Object.keys(storeElementEvent).length) {\n        return;\n      }\n      removeHandler(element2, events, typeEvent, callable, isDelegated ? handler : null);\n      return;\n    }\n    if (isNamespace) {\n      for (const elementEvent of Object.keys(events)) {\n        removeNamespacedHandlers(element2, events, elementEvent, originalTypeEvent.slice(1));\n      }\n    }\n    for (const [keyHandlers, event] of Object.entries(storeElementEvent)) {\n      const handlerKey = keyHandlers.replace(stripUidRegex, \"\");\n      if (!inNamespace || originalTypeEvent.includes(handlerKey)) {\n        removeHandler(element2, events, typeEvent, event.callable, event.delegationSelector);\n      }\n    }\n  },\n  trigger(element2, event, args) {\n    if (typeof event !== \"string\" || !element2) {\n      return null;\n    }\n    const $2 = getjQuery();\n    const typeEvent = getTypeEvent(event);\n    const inNamespace = event !== typeEvent;\n    let jQueryEvent = null;\n    let bubbles = true;\n    let nativeDispatch = true;\n    let defaultPrevented = false;\n    if (inNamespace && $2) {\n      jQueryEvent = $2.Event(event, args);\n      $2(element2).trigger(jQueryEvent);\n      bubbles = !jQueryEvent.isPropagationStopped();\n      nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();\n      defaultPrevented = jQueryEvent.isDefaultPrevented();\n    }\n    const evt = hydrateObj(new Event(event, { bubbles, cancelable: true }), args);\n    if (defaultPrevented) {\n      evt.preventDefault();\n    }\n    if (nativeDispatch) {\n      element2.dispatchEvent(evt);\n    }\n    if (evt.defaultPrevented && jQueryEvent) {\n      jQueryEvent.preventDefault();\n    }\n    return evt;\n  }\n};\nfunction hydrateObj(obj, meta = {}) {\n  for (const [key, value] of Object.entries(meta)) {\n    try {\n      obj[key] = value;\n    } catch {\n      Object.defineProperty(obj, key, {\n        configurable: true,\n        get() {\n          return value;\n        }\n      });\n    }\n  }\n  return obj;\n}\nfunction normalizeData(value) {\n  if (value === \"true\") {\n    return true;\n  }\n  if (value === \"false\") {\n    return false;\n  }\n  if (value === Number(value).toString()) {\n    return Number(value);\n  }\n  if (value === \"\" || value === \"null\") {\n    return null;\n  }\n  if (typeof value !== \"string\") {\n    return value;\n  }\n  try {\n    return JSON.parse(decodeURIComponent(value));\n  } catch {\n    return value;\n  }\n}\nfunction normalizeDataKey(key) {\n  return key.replace(/[A-Z]/g, (chr) => `-${chr.toLowerCase()}`);\n}\nconst Manipulator = {\n  setDataAttribute(element2, key, value) {\n    element2.setAttribute(`data-mdb-${normalizeDataKey(key)}`, value);\n  },\n  removeDataAttribute(element2, key) {\n    element2.removeAttribute(`data-mdb-${normalizeDataKey(key)}`);\n  },\n  getDataAttributes(element2) {\n    if (!element2) {\n      return {};\n    }\n    const attributes = {};\n    const mdbKeys = Object.keys(element2.dataset).filter(\n      (key) => key.startsWith(\"mdb\") && !key.startsWith(\"mdbConfig\")\n    );\n    for (const key of mdbKeys) {\n      let pureKey = key.replace(/^mdb/, \"\");\n      pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);\n      attributes[pureKey] = normalizeData(element2.dataset[key]);\n    }\n    return attributes;\n  },\n  getDataAttribute(element2, key) {\n    return normalizeData(element2.getAttribute(`data-mdb-${normalizeDataKey(key)}`));\n  }\n};\nclass Config {\n  // Getters\n  static get Default() {\n    return {};\n  }\n  static get DefaultType() {\n    return {};\n  }\n  static get NAME() {\n    throw new Error('You have to implement the static method \"NAME\", for each component!');\n  }\n  _getConfig(config) {\n    config = this._mergeConfigObj(config);\n    config = this._configAfterMerge(config);\n    this._typeCheckConfig(config);\n    return config;\n  }\n  _configAfterMerge(config) {\n    return config;\n  }\n  _mergeConfigObj(config, element2) {\n    const jsonConfig = isElement$1(element2) ? Manipulator.getDataAttribute(element2, \"config\") : {};\n    return {\n      ...this.constructor.Default,\n      ...typeof jsonConfig === \"object\" ? jsonConfig : {},\n      ...isElement$1(element2) ? Manipulator.getDataAttributes(element2) : {},\n      ...typeof config === \"object\" ? config : {}\n    };\n  }\n  _typeCheckConfig(config, configTypes = this.constructor.DefaultType) {\n    for (const [property, expectedTypes] of Object.entries(configTypes)) {\n      const value = config[property];\n      const valueType = isElement$1(value) ? \"element\" : toType(value);\n      if (!new RegExp(expectedTypes).test(valueType)) {\n        throw new TypeError(\n          `${this.constructor.NAME.toUpperCase()}: Option \"${property}\" provided type \"${valueType}\" but expected type \"${expectedTypes}\".`\n        );\n      }\n    }\n  }\n}\nconst VERSION = \"5.3.3\";\nlet BaseComponent$1 = class BaseComponent extends Config {\n  constructor(element2, config) {\n    super();\n    element2 = getElement(element2);\n    if (!element2) {\n      return;\n    }\n    this._element = element2;\n    this._config = this._getConfig(config);\n    Data.set(this._element, this.constructor.DATA_KEY, this);\n  }\n  // Public\n  dispose() {\n    Data.remove(this._element, this.constructor.DATA_KEY);\n    EventHandler.off(this._element, this.constructor.EVENT_KEY);\n    for (const propertyName of Object.getOwnPropertyNames(this)) {\n      this[propertyName] = null;\n    }\n  }\n  _queueCallback(callback, element2, isAnimated = true) {\n    executeAfterTransition(callback, element2, isAnimated);\n  }\n  _getConfig(config) {\n    config = this._mergeConfigObj(config, this._element);\n    config = this._configAfterMerge(config);\n    this._typeCheckConfig(config);\n    return config;\n  }\n  // Static\n  static getInstance(element2) {\n    return Data.get(getElement(element2), this.DATA_KEY);\n  }\n  static getOrCreateInstance(element2, config = {}) {\n    return this.getInstance(element2) || new this(element2, typeof config === \"object\" ? config : null);\n  }\n  static get VERSION() {\n    return VERSION;\n  }\n  static get DATA_KEY() {\n    return `bs.${this.NAME}`;\n  }\n  static get EVENT_KEY() {\n    return `.${this.DATA_KEY}`;\n  }\n  static eventName(name) {\n    return `${name}${this.EVENT_KEY}`;\n  }\n};\nconst NAME$t = \"button\";\nconst CLASS_NAME_ACTIVE$5 = \"active\";\nlet Button$1 = class Button extends BaseComponent$1 {\n  // Getters\n  static get NAME() {\n    return NAME$t;\n  }\n  // Public\n  toggle() {\n    this._element.setAttribute(\"aria-pressed\", this._element.classList.toggle(CLASS_NAME_ACTIVE$5));\n  }\n  // Static\n  static jQueryInterface(config) {\n    return this.each(function() {\n      const data = Button.getOrCreateInstance(this);\n      if (config === \"toggle\") {\n        data[config]();\n      }\n    });\n  }\n};\nconst mapComponentsData = (() => {\n  const componentsData = [];\n  return {\n    set(componentName) {\n      componentsData.push(componentName);\n    },\n    get(componentName) {\n      return componentsData.includes(componentName);\n    }\n  };\n})();\nconst InitializedComponents = {\n  set(componentName) {\n    mapComponentsData.set(componentName);\n  },\n  get(componentName) {\n    return mapComponentsData.get(componentName);\n  }\n};\nconst isInitialized = (componentName) => {\n  return InitializedComponents.get(componentName);\n};\nconst bindCallbackEventsIfNeeded = (component) => {\n  if (!isInitialized(component.NAME)) {\n    const manualInit = true;\n    initComponent(component, manualInit);\n  }\n};\nconst initComponent = (component, manualInit = false) => {\n  if (!component || InitializedComponents.get(component.NAME)) {\n    return;\n  }\n  if (!manualInit) {\n    InitializedComponents.set(component.NAME);\n  }\n  const thisComponent = _defaultInitSelectors[component.NAME] || null;\n  const isToggler = (thisComponent == null ? void 0 : thisComponent.isToggler) || false;\n  defineJQueryPlugin(component);\n  if (thisComponent == null ? void 0 : thisComponent.advanced) {\n    thisComponent.advanced(component, thisComponent == null ? void 0 : thisComponent.selector);\n    return;\n  }\n  if (isToggler) {\n    thisComponent.callback(component, thisComponent == null ? void 0 : thisComponent.selector);\n    return;\n  }\n  if (manualInit) {\n    return;\n  }\n  SelectorEngine$1.find(thisComponent == null ? void 0 : thisComponent.selector).forEach((element2) => {\n    let instance = component.getInstance(element2);\n    if (!instance) {\n      instance = new component(element2);\n      if (thisComponent == null ? void 0 : thisComponent.onInit) {\n        instance[thisComponent.onInit]();\n      }\n    }\n  });\n};\nlet _defaultInitSelectors;\nclass InitMDB {\n  constructor(defaultInitSelectors2) {\n    __publicField(this, \"init\", (components) => {\n      components.forEach((component) => initComponent(component));\n    });\n    __publicField(this, \"initMDB\", (components, checkOtherImports = false) => {\n      const componentList = Object.keys(_defaultInitSelectors).map((element2) => {\n        const requireAutoInit = Boolean(\n          document.querySelector(_defaultInitSelectors[element2].selector)\n        );\n        if (requireAutoInit) {\n          const component = components[_defaultInitSelectors[element2].name];\n          if (!component && !InitializedComponents.get(element2) && checkOtherImports) {\n            console.warn(\n              `Please import ${_defaultInitSelectors[element2].name} from \"MDB\" package and add it to a object parameter inside \"initMDB\" function`\n            );\n          }\n          return component;\n        }\n        return null;\n      });\n      this.init(componentList);\n    });\n    _defaultInitSelectors = defaultInitSelectors2;\n  }\n}\nconst NAME$s = \"button\";\nconst DATA_KEY$g = `mdb.${NAME$s}`;\nconst EVENT_KEY$e = `.${DATA_KEY$g}`;\nconst EVENT_CLICK$2 = `click${EVENT_KEY$e}`;\nconst EVENT_TRANSITIONEND = \"transitionend\";\nconst EVENT_MOUSEENTER$2 = \"mouseenter\";\nconst EVENT_MOUSELEAVE$2 = \"mouseleave\";\nconst EVENT_HIDE$9 = `hide${EVENT_KEY$e}`;\nconst EVENT_HIDDEN$9 = `hidden${EVENT_KEY$e}`;\nconst EVENT_SHOW$9 = `show${EVENT_KEY$e}`;\nconst EVENT_SHOWN$9 = `shown${EVENT_KEY$e}`;\nconst CLASS_NAME_ACTIVE$4 = \"active\";\nconst CLASS_NAME_SHOWN = \"shown\";\nconst CLASS_NAME_FIXED_ACTION_BTN = \"fixed-action-btn\";\nconst SELECTOR_ACTION_BUTTON = \".fixed-action-btn:not(.smooth-scroll) > .btn-floating\";\nconst SELECTOR_LIST_ELEMENT = \"ul .btn\";\nconst SELECTOR_LIST$1 = \"ul\";\nclass Button2 extends Button$1 {\n  constructor(element2) {\n    super(element2);\n    this._fn = {};\n    if (this._element) {\n      Data$1.setData(this._element, DATA_KEY$g, this);\n      this._init();\n      Manipulator$1.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, true);\n      bindCallbackEventsIfNeeded(this.constructor);\n    }\n  }\n  // Static\n  static get NAME() {\n    return NAME$s;\n  }\n  static jQueryInterface(config, options) {\n    return this.each(function() {\n      let data = Data$1.getData(this, DATA_KEY$g);\n      const _config = typeof config === \"object\" && config;\n      if (!data && /dispose/.test(config)) {\n        return;\n      }\n      if (!data) {\n        data = new Button2(this, _config);\n      }\n      if (typeof config === \"string\") {\n        if (typeof data[config] === \"undefined\") {\n          throw new TypeError(`No method named \"${config}\"`);\n        }\n        data[config](options);\n      }\n    });\n  }\n  // Getters\n  get _actionButton() {\n    return SelectorEngine$1.findOne(SELECTOR_ACTION_BUTTON, this._element);\n  }\n  get _buttonListElements() {\n    return SelectorEngine$1.find(SELECTOR_LIST_ELEMENT, this._element);\n  }\n  get _buttonList() {\n    return SelectorEngine$1.findOne(SELECTOR_LIST$1, this._element);\n  }\n  get _isTouchDevice() {\n    return \"ontouchstart\" in document.documentElement;\n  }\n  // Public\n  show() {\n    if (Manipulator$1.hasClass(this._element, CLASS_NAME_FIXED_ACTION_BTN)) {\n      EventHandler$1.off(this._buttonList, EVENT_TRANSITIONEND);\n      EventHandler$1.trigger(this._element, EVENT_SHOW$9);\n      this._bindListOpenTransitionEnd();\n      Manipulator$1.addStyle(this._element, { height: `${this._fullContainerHeight}px` });\n      this._toggleVisibility(true);\n    }\n  }\n  hide() {\n    if (Manipulator$1.hasClass(this._element, CLASS_NAME_FIXED_ACTION_BTN)) {\n      EventHandler$1.off(this._buttonList, EVENT_TRANSITIONEND);\n      EventHandler$1.trigger(this._element, EVENT_HIDE$9);\n      this._bindListHideTransitionEnd();\n      this._toggleVisibility(false);\n    }\n  }\n  dispose() {\n    if (Manipulator$1.hasClass(this._element, CLASS_NAME_FIXED_ACTION_BTN)) {\n      EventHandler$1.off(this._actionButton, EVENT_CLICK$2);\n      this._actionButton.removeEventListener(EVENT_MOUSEENTER$2, this._fn.mouseenter);\n      this._element.removeEventListener(EVENT_MOUSELEAVE$2, this._fn.mouseleave);\n    }\n    Manipulator$1.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`);\n    super.dispose();\n  }\n  // Private\n  _init() {\n    if (Manipulator$1.hasClass(this._element, CLASS_NAME_FIXED_ACTION_BTN)) {\n      this._saveInitialHeights();\n      this._setInitialStyles();\n      this._bindInitialEvents();\n    }\n  }\n  _bindMouseEnter() {\n    this._actionButton.addEventListener(\n      EVENT_MOUSEENTER$2,\n      // prettier-ignore\n      this._fn.mouseenter = () => {\n        if (!this._isTouchDevice) {\n          this.show();\n        }\n      }\n      // prettier-ignore\n    );\n  }\n  _bindMouseLeave() {\n    this._element.addEventListener(\n      EVENT_MOUSELEAVE$2,\n      // prettier-ignore\n      this._fn.mouseleave = () => {\n        this.hide();\n      }\n      // prettier-ignore\n    );\n  }\n  _bindClick() {\n    EventHandler$1.on(this._actionButton, EVENT_CLICK$2, () => {\n      if (Manipulator$1.hasClass(this._element, CLASS_NAME_ACTIVE$4)) {\n        this.hide();\n      } else {\n        this.show();\n      }\n    });\n  }\n  _bindListHideTransitionEnd() {\n    EventHandler$1.on(this._buttonList, EVENT_TRANSITIONEND, (event) => {\n      if (event.propertyName === \"transform\") {\n        EventHandler$1.off(this._buttonList, EVENT_TRANSITIONEND);\n        this._element.style.height = `${this._initialContainerHeight}px`;\n        EventHandler$1.trigger(this._element, EVENT_HIDDEN$9);\n      }\n    });\n  }\n  _bindListOpenTransitionEnd() {\n    EventHandler$1.on(this._buttonList, EVENT_TRANSITIONEND, (event) => {\n      if (event.propertyName === \"transform\") {\n        EventHandler$1.off(this._buttonList, EVENT_TRANSITIONEND);\n        EventHandler$1.trigger(this._element, EVENT_SHOWN$9);\n      }\n    });\n  }\n  _toggleVisibility(isVisible2) {\n    const action = isVisible2 ? \"addClass\" : \"removeClass\";\n    const listTranslate = isVisible2 ? \"translate(0)\" : `translateY(${this._fullContainerHeight}px)`;\n    Manipulator$1.addStyle(this._buttonList, { transform: listTranslate });\n    if (this._buttonListElements) {\n      this._buttonListElements.forEach((el) => Manipulator$1[action](el, CLASS_NAME_SHOWN));\n    }\n    Manipulator$1[action](this._element, CLASS_NAME_ACTIVE$4);\n  }\n  _getHeight(element2) {\n    const computed = window.getComputedStyle(element2);\n    const height = parseFloat(computed.getPropertyValue(\"height\"));\n    return height;\n  }\n  _saveInitialHeights() {\n    this._initialContainerHeight = this._getHeight(this._element);\n    this._initialListHeight = this._getHeight(this._buttonList);\n    this._fullContainerHeight = this._initialContainerHeight + this._initialListHeight;\n  }\n  _bindInitialEvents() {\n    this._bindClick();\n    this._bindMouseEnter();\n    this._bindMouseLeave();\n  }\n  _setInitialStyles() {\n    this._buttonList.style.marginBottom = `${this._initialContainerHeight}px`;\n    this._buttonList.style.transform = `translateY(${this._fullContainerHeight}px)`;\n    this._element.style.height = `${this._initialContainerHeight}px`;\n  }\n}\nconst getSelector = (element2) => {\n  let selector = element2.getAttribute(\"data-mdb-target\");\n  if (!selector || selector === \"#\") {\n    let hrefAttribute = element2.getAttribute(\"href\");\n    if (!hrefAttribute || !hrefAttribute.includes(\"#\") && !hrefAttribute.startsWith(\".\")) {\n      return null;\n    }\n    if (hrefAttribute.includes(\"#\") && !hrefAttribute.startsWith(\"#\")) {\n      hrefAttribute = `#${hrefAttribute.split(\"#\")[1]}`;\n    }\n    selector = hrefAttribute && hrefAttribute !== \"#\" ? hrefAttribute.trim() : null;\n  }\n  return selector ? selector.split(\",\").map((sel) => parseSelector(sel)).join(\",\") : null;\n};\nconst SelectorEngine = {\n  find(selector, element2 = document.documentElement) {\n    return [].concat(...Element.prototype.querySelectorAll.call(element2, selector));\n  },\n  findOne(selector, element2 = document.documentElement) {\n    return Element.prototype.querySelector.call(element2, selector);\n  },\n  children(element2, selector) {\n    return [].concat(...element2.children).filter((child) => child.matches(selector));\n  },\n  parents(element2, selector) {\n    const parents = [];\n    let ancestor = element2.parentNode.closest(selector);\n    while (ancestor) {\n      parents.push(ancestor);\n      ancestor = ancestor.parentNode.closest(selector);\n    }\n    return parents;\n  },\n  prev(element2, selector) {\n    let previous = element2.previousElementSibling;\n    while (previous) {\n      if (previous.matches(selector)) {\n        return [previous];\n      }\n      previous = previous.previousElementSibling;\n    }\n    return [];\n  },\n  // TODO: this is now unused; remove later along with prev()\n  next(element2, selector) {\n    let next = element2.nextElementSibling;\n    while (next) {\n      if (next.matches(selector)) {\n        return [next];\n      }\n      next = next.nextElementSibling;\n    }\n    return [];\n  },\n  focusableChildren(element2) {\n    const focusables = [\n      \"a\",\n      \"button\",\n      \"input\",\n      \"textarea\",\n      \"select\",\n      \"details\",\n      \"[tabindex]\",\n      '[contenteditable=\"true\"]'\n    ].map((selector) => `${selector}:not([tabindex^=\"-\"])`).join(\",\");\n    return this.find(focusables, element2).filter((el) => !isDisabled(el) && isVisible(el));\n  },\n  getSelectorFromElement(element2) {\n    const selector = getSelector(element2);\n    if (selector) {\n      return SelectorEngine.findOne(selector) ? selector : null;\n    }\n    return null;\n  },\n  getElementFromSelector(element2) {\n    const selector = getSelector(element2);\n    return selector ? SelectorEngine.findOne(selector) : null;\n  },\n  getMultipleElementsFromSelector(element2) {\n    const selector = getSelector(element2);\n    return selector ? SelectorEngine.find(selector) : [];\n  }\n};\nconst NAME$r = \"backdrop\";\nconst CLASS_NAME_FADE$6 = \"fade\";\nconst CLASS_NAME_SHOW$9 = \"show\";\nconst EVENT_MOUSEDOWN = `mousedown.bs.${NAME$r}`;\nconst Default$e = {\n  className: \"modal-backdrop\",\n  clickCallback: null,\n  isAnimated: false,\n  isVisible: true,\n  // if false, we use the backdrop helper without adding any element to the dom\n  rootElement: \"body\"\n  // give the choice to place backdrop under different elements\n};\nconst DefaultType$e = {\n  className: \"string\",\n  clickCallback: \"(function|null)\",\n  isAnimated: \"boolean\",\n  isVisible: \"boolean\",\n  rootElement: \"(element|string)\"\n};\nclass Backdrop extends Config {\n  constructor(config) {\n    super();\n    this._config = this._getConfig(config);\n    this._isAppended = false;\n    this._element = null;\n  }\n  // Getters\n  static get Default() {\n    return Default$e;\n  }\n  static get DefaultType() {\n    return DefaultType$e;\n  }\n  static get NAME() {\n    return NAME$r;\n  }\n  // Public\n  show(callback) {\n    if (!this._config.isVisible) {\n      execute(callback);\n      return;\n    }\n    this._append();\n    const element2 = this._getElement();\n    if (this._config.isAnimated) {\n      reflow(element2);\n    }\n    element2.classList.add(CLASS_NAME_SHOW$9);\n    this._emulateAnimation(() => {\n      execute(callback);\n    });\n  }\n  hide(callback) {\n    if (!this._config.isVisible) {\n      execute(callback);\n      return;\n    }\n    this._getElement().classList.remove(CLASS_NAME_SHOW$9);\n    this._emulateAnimation(() => {\n      this.dispose();\n      execute(callback);\n    });\n  }\n  dispose() {\n    if (!this._isAppended) {\n      return;\n    }\n    EventHandler.off(this._element, EVENT_MOUSEDOWN);\n    this._element.remove();\n    this._isAppended = false;\n  }\n  // Private\n  _getElement() {\n    if (!this._element) {\n      const backdrop = document.createElement(\"div\");\n      backdrop.className = this._config.className;\n      if (this._config.isAnimated) {\n        backdrop.classList.add(CLASS_NAME_FADE$6);\n      }\n      this._element = backdrop;\n    }\n    return this._element;\n  }\n  _configAfterMerge(config) {\n    config.rootElement = getElement(config.rootElement);\n    return config;\n  }\n  _append() {\n    if (this._isAppended) {\n      return;\n    }\n    const element2 = this._getElement();\n    this._config.rootElement.append(element2);\n    EventHandler.on(element2, EVENT_MOUSEDOWN, () => {\n      execute(this._config.clickCallback);\n    });\n    this._isAppended = true;\n  }\n  _emulateAnimation(callback) {\n    executeAfterTransition(callback, this._getElement(), this._config.isAnimated);\n  }\n}\nconst enableDismissTrigger = (component, method = \"hide\") => {\n  const clickEvent = `click.dismiss${component.EVENT_KEY}`;\n  const name = component.NAME;\n  EventHandler.on(document, clickEvent, `[data-mdb-dismiss=\"${name}\"]`, function(event) {\n    if ([\"A\", \"AREA\"].includes(this.tagName)) {\n      event.preventDefault();\n    }\n    if (isDisabled(this)) {\n      return;\n    }\n    const target = SelectorEngine.getElementFromSelector(this) || this.closest(`.${name}`);\n    const instance = component.getOrCreateInstance(target);\n    instance[method]();\n  });\n};\nconst NAME$q = \"focustrap\";\nconst DATA_KEY$f = \"bs.focustrap\";\nconst EVENT_KEY$d = `.${DATA_KEY$f}`;\nconst EVENT_FOCUSIN$2 = `focusin${EVENT_KEY$d}`;\nconst EVENT_KEYDOWN_TAB = `keydown.tab${EVENT_KEY$d}`;\nconst TAB_KEY$1 = \"Tab\";\nconst TAB_NAV_FORWARD = \"forward\";\nconst TAB_NAV_BACKWARD = \"backward\";\nconst Default$d = {\n  autofocus: true,\n  trapElement: null\n  // The element to trap focus inside of\n};\nconst DefaultType$d = {\n  autofocus: \"boolean\",\n  trapElement: \"element\"\n};\nclass FocusTrap extends Config {\n  constructor(config) {\n    super();\n    this._config = this._getConfig(config);\n    this._isActive = false;\n    this._lastTabNavDirection = null;\n  }\n  // Getters\n  static get Default() {\n    return Default$d;\n  }\n  static get DefaultType() {\n    return DefaultType$d;\n  }\n  static get NAME() {\n    return NAME$q;\n  }\n  // Public\n  activate() {\n    if (this._isActive) {\n      return;\n    }\n    if (this._config.autofocus) {\n      this._config.trapElement.focus();\n    }\n    EventHandler.off(document, EVENT_KEY$d);\n    EventHandler.on(document, EVENT_FOCUSIN$2, (event) => this._handleFocusin(event));\n    EventHandler.on(document, EVENT_KEYDOWN_TAB, (event) => this._handleKeydown(event));\n    this._isActive = true;\n  }\n  deactivate() {\n    if (!this._isActive) {\n      return;\n    }\n    this._isActive = false;\n    EventHandler.off(document, EVENT_KEY$d);\n  }\n  // Private\n  _handleFocusin(event) {\n    const { trapElement } = this._config;\n    if (event.target === document || event.target === trapElement || trapElement.contains(event.target)) {\n      return;\n    }\n    const elements = SelectorEngine.focusableChildren(trapElement);\n    if (elements.length === 0) {\n      trapElement.focus();\n    } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {\n      elements[elements.length - 1].focus();\n    } else {\n      elements[0].focus();\n    }\n  }\n  _handleKeydown(event) {\n    if (event.key !== TAB_KEY$1) {\n      return;\n    }\n    this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;\n  }\n}\nconst SELECTOR_FIXED_CONTENT = \".fixed-top, .fixed-bottom, .is-fixed, .sticky-top\";\nconst SELECTOR_STICKY_CONTENT = \".sticky-top\";\nconst PROPERTY_PADDING = \"padding-right\";\nconst PROPERTY_MARGIN = \"margin-right\";\nclass ScrollBarHelper {\n  constructor() {\n    this._element = document.body;\n  }\n  // Public\n  getWidth() {\n    const documentWidth = document.documentElement.clientWidth;\n    return Math.abs(window.innerWidth - documentWidth);\n  }\n  hide() {\n    const width = this.getWidth();\n    this._disableOverFlow();\n    this._setElementAttributes(\n      this._element,\n      PROPERTY_PADDING,\n      (calculatedValue) => calculatedValue + width\n    );\n    this._setElementAttributes(\n      SELECTOR_FIXED_CONTENT,\n      PROPERTY_PADDING,\n      (calculatedValue) => calculatedValue + width\n    );\n    this._setElementAttributes(\n      SELECTOR_STICKY_CONTENT,\n      PROPERTY_MARGIN,\n      (calculatedValue) => calculatedValue - width\n    );\n  }\n  reset() {\n    this._resetElementAttributes(this._element, \"overflow\");\n    this._resetElementAttributes(this._element, PROPERTY_PADDING);\n    this._resetElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING);\n    this._resetElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN);\n  }\n  isOverflowing() {\n    return this.getWidth() > 0;\n  }\n  // Private\n  _disableOverFlow() {\n    this._saveInitialAttribute(this._element, \"overflow\");\n    this._element.style.overflow = \"hidden\";\n  }\n  _setElementAttributes(selector, styleProperty, callback) {\n    const scrollbarWidth = this.getWidth();\n    const manipulationCallBack = (element2) => {\n      if (element2 !== this._element && window.innerWidth > element2.clientWidth + scrollbarWidth) {\n        return;\n      }\n      this._saveInitialAttribute(element2, styleProperty);\n      const calculatedValue = window.getComputedStyle(element2).getPropertyValue(styleProperty);\n      element2.style.setProperty(styleProperty, `${callback(Number.parseFloat(calculatedValue))}px`);\n    };\n    this._applyManipulationCallback(selector, manipulationCallBack);\n  }\n  _saveInitialAttribute(element2, styleProperty) {\n    const actualValue = element2.style.getPropertyValue(styleProperty);\n    if (actualValue) {\n      Manipulator.setDataAttribute(element2, styleProperty, actualValue);\n    }\n  }\n  _resetElementAttributes(selector, styleProperty) {\n    const manipulationCallBack = (element2) => {\n      const value = Manipulator.getDataAttribute(element2, styleProperty);\n      if (value === null) {\n        element2.style.removeProperty(styleProperty);\n        return;\n      }\n      Manipulator.removeDataAttribute(element2, styleProperty);\n      element2.style.setProperty(styleProperty, value);\n    };\n    this._applyManipulationCallback(selector, manipulationCallBack);\n  }\n  _applyManipulationCallback(selector, callBack) {\n    if (isElement$1(selector)) {\n      callBack(selector);\n      return;\n    }\n    for (const sel of SelectorEngine.find(selector, this._element)) {\n      callBack(sel);\n    }\n  }\n}\nconst NAME$p = \"offcanvas\";\nconst DATA_KEY$e = \"bs.offcanvas\";\nconst EVENT_KEY$c = `.${DATA_KEY$e}`;\nconst ESCAPE_KEY$2 = \"Escape\";\nconst CLASS_NAME_SHOW$8 = \"show\";\nconst CLASS_NAME_SHOWING$1 = \"showing\";\nconst CLASS_NAME_HIDING = \"hiding\";\nconst CLASS_NAME_BACKDROP = \"offcanvas-backdrop\";\nconst EVENT_SHOW$8 = `show${EVENT_KEY$c}`;\nconst EVENT_SHOWN$8 = `shown${EVENT_KEY$c}`;\nconst EVENT_HIDE$8 = `hide${EVENT_KEY$c}`;\nconst EVENT_HIDE_PREVENTED$1 = `hidePrevented${EVENT_KEY$c}`;\nconst EVENT_HIDDEN$8 = `hidden${EVENT_KEY$c}`;\nconst EVENT_KEYDOWN_DISMISS$1 = `keydown.dismiss${EVENT_KEY$c}`;\nconst Default$c = {\n  backdrop: true,\n  keyboard: true,\n  scroll: false\n};\nconst DefaultType$c = {\n  backdrop: \"(boolean|string)\",\n  keyboard: \"boolean\",\n  scroll: \"boolean\"\n};\nclass Offcanvas extends BaseComponent$1 {\n  constructor(element2, config) {\n    super(element2, config);\n    this._isShown = false;\n    this._backdrop = this._initializeBackDrop();\n    this._focustrap = this._initializeFocusTrap();\n    this._addEventListeners();\n  }\n  // Getters\n  static get Default() {\n    return Default$c;\n  }\n  static get DefaultType() {\n    return DefaultType$c;\n  }\n  static get NAME() {\n    return NAME$p;\n  }\n  // Public\n  toggle(relatedTarget) {\n    return this._isShown ? this.hide() : this.show(relatedTarget);\n  }\n  show(relatedTarget) {\n    if (this._isShown) {\n      return;\n    }\n    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$8, { relatedTarget });\n    if (showEvent.defaultPrevented) {\n      return;\n    }\n    this._isShown = true;\n    this._backdrop.show();\n    if (!this._config.scroll) {\n      new ScrollBarHelper().hide();\n    }\n    this._element.setAttribute(\"aria-modal\", true);\n    this._element.setAttribute(\"role\", \"dialog\");\n    this._element.classList.add(CLASS_NAME_SHOWING$1);\n    const completeCallBack = () => {\n      if (!this._config.scroll || this._config.backdrop) {\n        this._focustrap.activate();\n      }\n      this._element.classList.add(CLASS_NAME_SHOW$8);\n      this._element.classList.remove(CLASS_NAME_SHOWING$1);\n      EventHandler.trigger(this._element, EVENT_SHOWN$8, { relatedTarget });\n    };\n    this._queueCallback(completeCallBack, this._element, true);\n  }\n  hide() {\n    if (!this._isShown) {\n      return;\n    }\n    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$8);\n    if (hideEvent.defaultPrevented) {\n      return;\n    }\n    this._focustrap.deactivate();\n    this._element.blur();\n    this._isShown = false;\n    this._element.classList.add(CLASS_NAME_HIDING);\n    this._backdrop.hide();\n    const completeCallback = () => {\n      this._element.classList.remove(CLASS_NAME_SHOW$8, CLASS_NAME_HIDING);\n      this._element.removeAttribute(\"aria-modal\");\n      this._element.removeAttribute(\"role\");\n      if (!this._config.scroll) {\n        new ScrollBarHelper().reset();\n      }\n      EventHandler.trigger(this._element, EVENT_HIDDEN$8);\n    };\n    this._queueCallback(completeCallback, this._element, true);\n  }\n  dispose() {\n    this._backdrop.dispose();\n    this._focustrap.deactivate();\n    super.dispose();\n  }\n  // Private\n  _initializeBackDrop() {\n    const clickCallback = () => {\n      if (this._config.backdrop === \"static\") {\n        EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED$1);\n        return;\n      }\n      this.hide();\n    };\n    const isVisible2 = Boolean(this._config.backdrop);\n    return new Backdrop({\n      className: CLASS_NAME_BACKDROP,\n      isVisible: isVisible2,\n      isAnimated: true,\n      rootElement: this._element.parentNode,\n      clickCallback: isVisible2 ? clickCallback : null\n    });\n  }\n  _initializeFocusTrap() {\n    return new FocusTrap({\n      trapElement: this._element\n    });\n  }\n  _addEventListeners() {\n    EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, (event) => {\n      if (event.key !== ESCAPE_KEY$2) {\n        return;\n      }\n      if (this._config.keyboard) {\n        this.hide();\n        return;\n      }\n      EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED$1);\n    });\n  }\n  // Static\n  static jQueryInterface(config) {\n    return this.each(function() {\n      const data = Offcanvas.getOrCreateInstance(this, config);\n      if (typeof config !== \"string\") {\n        return;\n      }\n      if (data[config] === void 0 || config.startsWith(\"_\") || config === \"constructor\") {\n        throw new TypeError(`No method named \"${config}\"`);\n      }\n      data[config](this);\n    });\n  }\n}\nconst NAME$o = \"alert\";\nconst DATA_KEY$d = \"bs.alert\";\nconst EVENT_KEY$b = `.${DATA_KEY$d}`;\nconst EVENT_CLOSE = `close${EVENT_KEY$b}`;\nconst EVENT_CLOSED = `closed${EVENT_KEY$b}`;\nconst CLASS_NAME_FADE$5 = \"fade\";\nconst CLASS_NAME_SHOW$7 = \"show\";\nlet Alert$1 = class Alert extends BaseComponent$1 {\n  // Getters\n  static get NAME() {\n    return NAME$o;\n  }\n  // Public\n  close() {\n    const closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);\n    if (closeEvent.defaultPrevented) {\n      return;\n    }\n    this._element.classList.remove(CLASS_NAME_SHOW$7);\n    const isAnimated = this._element.classList.contains(CLASS_NAME_FADE$5);\n    this._queueCallback(() => this._destroyElement(), this._element, isAnimated);\n  }\n  // Private\n  _destroyElement() {\n    this._element.remove();\n    EventHandler.trigger(this._element, EVENT_CLOSED);\n    this.dispose();\n  }\n  // Static\n  static jQueryInterface(config) {\n    return this.each(function() {\n      const data = Alert.getOrCreateInstance(this);\n      if (typeof config !== \"string\") {\n        return;\n      }\n      if (data[config] === void 0 || config.startsWith(\"_\") || config === \"constructor\") {\n        throw new TypeError(`No method named \"${config}\"`);\n      }\n      data[config](this);\n    });\n  }\n};\nconst NAME$n = \"alert\";\nconst EVENT_CLOSE_BS = \"close.bs.alert\";\nconst EVENT_CLOSED_BS = \"closed.bs.alert\";\nconst EXTENDED_EVENTS$6 = [{ name: \"close\" }, { name: \"closed\" }];\nclass Alert2 extends Alert$1 {\n  constructor(element2, data = {}) {\n    super(element2, data);\n    this._init();\n    Manipulator$1.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, true);\n    bindCallbackEventsIfNeeded(this.constructor);\n  }\n  dispose() {\n    EventHandler$1.off(this._element, EVENT_CLOSE_BS);\n    EventHandler$1.off(this._element, EVENT_CLOSED_BS);\n    Manipulator$1.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`);\n    super.dispose();\n  }\n  // Getters\n  static get NAME() {\n    return NAME$n;\n  }\n  // Private\n  _init() {\n    this._bindMdbEvents();\n  }\n  _bindMdbEvents() {\n    EventHandler$1.extend(this._element, EXTENDED_EVENTS$6, NAME$n);\n  }\n}\nconst NAME$m = \"swipe\";\nconst EVENT_KEY$a = \".bs.swipe\";\nconst EVENT_TOUCHSTART = `touchstart${EVENT_KEY$a}`;\nconst EVENT_TOUCHMOVE = `touchmove${EVENT_KEY$a}`;\nconst EVENT_TOUCHEND = `touchend${EVENT_KEY$a}`;\nconst EVENT_POINTERDOWN = `pointerdown${EVENT_KEY$a}`;\nconst EVENT_POINTERUP = `pointerup${EVENT_KEY$a}`;\nconst POINTER_TYPE_TOUCH = \"touch\";\nconst POINTER_TYPE_PEN = \"pen\";\nconst CLASS_NAME_POINTER_EVENT = \"pointer-event\";\nconst SWIPE_THRESHOLD = 40;\nconst Default$b = {\n  endCallback: null,\n  leftCallback: null,\n  rightCallback: null\n};\nconst DefaultType$b = {\n  endCallback: \"(function|null)\",\n  leftCallback: \"(function|null)\",\n  rightCallback: \"(function|null)\"\n};\nclass Swipe extends Config {\n  constructor(element2, config) {\n    super();\n    this._element = element2;\n    if (!element2 || !Swipe.isSupported()) {\n      return;\n    }\n    this._config = this._getConfig(config);\n    this._deltaX = 0;\n    this._supportPointerEvents = Boolean(window.PointerEvent);\n    this._initEvents();\n  }\n  // Getters\n  static get Default() {\n    return Default$b;\n  }\n  static get DefaultType() {\n    return DefaultType$b;\n  }\n  static get NAME() {\n    return NAME$m;\n  }\n  // Public\n  dispose() {\n    EventHandler.off(this._element, EVENT_KEY$a);\n  }\n  // Private\n  _start(event) {\n    if (!this._supportPointerEvents) {\n      this._deltaX = event.touches[0].clientX;\n      return;\n    }\n    if (this._eventIsPointerPenTouch(event)) {\n      this._deltaX = event.clientX;\n    }\n  }\n  _end(event) {\n    if (this._eventIsPointerPenTouch(event)) {\n      this._deltaX = event.clientX - this._deltaX;\n    }\n    this._handleSwipe();\n    execute(this._config.endCallback);\n  }\n  _move(event) {\n    this._deltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this._deltaX;\n  }\n  _handleSwipe() {\n    const absDeltaX = Math.abs(this._deltaX);\n    if (absDeltaX <= SWIPE_THRESHOLD) {\n      return;\n    }\n    const direction = absDeltaX / this._deltaX;\n    this._deltaX = 0;\n    if (!direction) {\n      return;\n    }\n    execute(direction > 0 ? this._config.rightCallback : this._config.leftCallback);\n  }\n  _initEvents() {\n    if (this._supportPointerEvents) {\n      EventHandler.on(this._element, EVENT_POINTERDOWN, (event) => this._start(event));\n      EventHandler.on(this._element, EVENT_POINTERUP, (event) => this._end(event));\n      this._element.classList.add(CLASS_NAME_POINTER_EVENT);\n    } else {\n      EventHandler.on(this._element, EVENT_TOUCHSTART, (event) => this._start(event));\n      EventHandler.on(this._element, EVENT_TOUCHMOVE, (event) => this._move(event));\n      EventHandler.on(this._element, EVENT_TOUCHEND, (event) => this._end(event));\n    }\n  }\n  _eventIsPointerPenTouch(event) {\n    return this._supportPointerEvents && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);\n  }\n  // Static\n  static isSupported() {\n    return \"ontouchstart\" in document.documentElement || navigator.maxTouchPoints > 0;\n  }\n}\nconst NAME$l = \"carousel\";\nconst DATA_KEY$c = \"bs.carousel\";\nconst EVENT_KEY$9 = `.${DATA_KEY$c}`;\nconst ARROW_LEFT_KEY$1 = \"ArrowLeft\";\nconst ARROW_RIGHT_KEY$1 = \"ArrowRight\";\nconst TOUCHEVENT_COMPAT_WAIT = 500;\nconst ORDER_NEXT = \"next\";\nconst ORDER_PREV = \"prev\";\nconst DIRECTION_LEFT = \"left\";\nconst DIRECTION_RIGHT = \"right\";\nconst EVENT_SLIDE = `slide${EVENT_KEY$9}`;\nconst EVENT_SLID = `slid${EVENT_KEY$9}`;\nconst EVENT_KEYDOWN$1 = `keydown${EVENT_KEY$9}`;\nconst EVENT_MOUSEENTER$1 = `mouseenter${EVENT_KEY$9}`;\nconst EVENT_MOUSELEAVE$1 = `mouseleave${EVENT_KEY$9}`;\nconst EVENT_DRAG_START = `dragstart${EVENT_KEY$9}`;\nconst CLASS_NAME_CAROUSEL = \"carousel\";\nconst CLASS_NAME_ACTIVE$3 = \"active\";\nconst CLASS_NAME_SLIDE = \"slide\";\nconst CLASS_NAME_END = \"carousel-item-end\";\nconst CLASS_NAME_START = \"carousel-item-start\";\nconst CLASS_NAME_NEXT = \"carousel-item-next\";\nconst CLASS_NAME_PREV = \"carousel-item-prev\";\nconst SELECTOR_ACTIVE$1 = \".active\";\nconst SELECTOR_ITEM = \".carousel-item\";\nconst SELECTOR_ACTIVE_ITEM = SELECTOR_ACTIVE$1 + SELECTOR_ITEM;\nconst SELECTOR_ITEM_IMG = \".carousel-item img\";\nconst SELECTOR_INDICATORS = \".carousel-indicators\";\nconst KEY_TO_DIRECTION = {\n  [ARROW_LEFT_KEY$1]: DIRECTION_RIGHT,\n  [ARROW_RIGHT_KEY$1]: DIRECTION_LEFT\n};\nconst Default$a = {\n  interval: 5e3,\n  keyboard: true,\n  pause: \"hover\",\n  ride: false,\n  touch: true,\n  wrap: true\n};\nconst DefaultType$a = {\n  interval: \"(number|boolean)\",\n  // TODO:v6 remove boolean support\n  keyboard: \"boolean\",\n  pause: \"(string|boolean)\",\n  ride: \"(boolean|string)\",\n  touch: \"boolean\",\n  wrap: \"boolean\"\n};\nlet Carousel$1 = class Carousel extends BaseComponent$1 {\n  constructor(element2, config) {\n    super(element2, config);\n    this._interval = null;\n    this._activeElement = null;\n    this._isSliding = false;\n    this.touchTimeout = null;\n    this._swipeHelper = null;\n    this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element);\n    this._addEventListeners();\n    if (this._config.ride === CLASS_NAME_CAROUSEL) {\n      this.cycle();\n    }\n  }\n  // Getters\n  static get Default() {\n    return Default$a;\n  }\n  static get DefaultType() {\n    return DefaultType$a;\n  }\n  static get NAME() {\n    return NAME$l;\n  }\n  // Public\n  next() {\n    this._slide(ORDER_NEXT);\n  }\n  nextWhenVisible() {\n    if (!document.hidden && isVisible(this._element)) {\n      this.next();\n    }\n  }\n  prev() {\n    this._slide(ORDER_PREV);\n  }\n  pause() {\n    if (this._isSliding) {\n      triggerTransitionEnd(this._element);\n    }\n    this._clearInterval();\n  }\n  cycle() {\n    this._clearInterval();\n    this._updateInterval();\n    this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval);\n  }\n  _maybeEnableCycle() {\n    if (!this._config.ride) {\n      return;\n    }\n    if (this._isSliding) {\n      EventHandler.one(this._element, EVENT_SLID, () => this.cycle());\n      return;\n    }\n    this.cycle();\n  }\n  to(index) {\n    const items = this._getItems();\n    if (index > items.length - 1 || index < 0) {\n      return;\n    }\n    if (this._isSliding) {\n      EventHandler.one(this._element, EVENT_SLID, () => this.to(index));\n      return;\n    }\n    const activeIndex = this._getItemIndex(this._getActive());\n    if (activeIndex === index) {\n      return;\n    }\n    const order2 = index > activeIndex ? ORDER_NEXT : ORDER_PREV;\n    this._slide(order2, items[index]);\n  }\n  dispose() {\n    if (this._swipeHelper) {\n      this._swipeHelper.dispose();\n    }\n    super.dispose();\n  }\n  // Private\n  _configAfterMerge(config) {\n    config.defaultInterval = config.interval;\n    return config;\n  }\n  _addEventListeners() {\n    if (this._config.keyboard) {\n      EventHandler.on(this._element, EVENT_KEYDOWN$1, (event) => this._keydown(event));\n    }\n    if (this._config.pause === \"hover\") {\n      EventHandler.on(this._element, EVENT_MOUSEENTER$1, () => this.pause());\n      EventHandler.on(this._element, EVENT_MOUSELEAVE$1, () => this._maybeEnableCycle());\n    }\n    if (this._config.touch && Swipe.isSupported()) {\n      this._addTouchEventListeners();\n    }\n  }\n  _addTouchEventListeners() {\n    for (const img of SelectorEngine.find(SELECTOR_ITEM_IMG, this._element)) {\n      EventHandler.on(img, EVENT_DRAG_START, (event) => event.preventDefault());\n    }\n    const endCallBack = () => {\n      if (this._config.pause !== \"hover\") {\n        return;\n      }\n      this.pause();\n      if (this.touchTimeout) {\n        clearTimeout(this.touchTimeout);\n      }\n      this.touchTimeout = setTimeout(\n        () => this._maybeEnableCycle(),\n        TOUCHEVENT_COMPAT_WAIT + this._config.interval\n      );\n    };\n    const swipeConfig = {\n      leftCallback: () => this._slide(this._directionToOrder(DIRECTION_LEFT)),\n      rightCallback: () => this._slide(this._directionToOrder(DIRECTION_RIGHT)),\n      endCallback: endCallBack\n    };\n    this._swipeHelper = new Swipe(this._element, swipeConfig);\n  }\n  _keydown(event) {\n    if (/input|textarea/i.test(event.target.tagName)) {\n      return;\n    }\n    const direction = KEY_TO_DIRECTION[event.key];\n    if (direction) {\n      event.preventDefault();\n      this._slide(this._directionToOrder(direction));\n    }\n  }\n  _getItemIndex(element2) {\n    return this._getItems().indexOf(element2);\n  }\n  _setActiveIndicatorElement(index) {\n    if (!this._indicatorsElement) {\n      return;\n    }\n    const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE$1, this._indicatorsElement);\n    activeIndicator.classList.remove(CLASS_NAME_ACTIVE$3);\n    activeIndicator.removeAttribute(\"aria-current\");\n    const newActiveIndicator = SelectorEngine.findOne(\n      `[data-mdb-slide-to=\"${index}\"]`,\n      this._indicatorsElement\n    );\n    if (newActiveIndicator) {\n      newActiveIndicator.classList.add(CLASS_NAME_ACTIVE$3);\n      newActiveIndicator.setAttribute(\"aria-current\", \"true\");\n    }\n  }\n  _updateInterval() {\n    const element2 = this._activeElement || this._getActive();\n    if (!element2) {\n      return;\n    }\n    const elementInterval = Number.parseInt(element2.getAttribute(\"data-mdb-interval\"), 10);\n    this._config.interval = elementInterval || this._config.defaultInterval;\n  }\n  _slide(order2, element2 = null) {\n    if (this._isSliding) {\n      return;\n    }\n    const activeElement = this._getActive();\n    const isNext = order2 === ORDER_NEXT;\n    const nextElement = element2 || getNextActiveElement(this._getItems(), activeElement, isNext, this._config.wrap);\n    if (nextElement === activeElement) {\n      return;\n    }\n    const nextElementIndex = this._getItemIndex(nextElement);\n    const triggerEvent = (eventName) => {\n      return EventHandler.trigger(this._element, eventName, {\n        relatedTarget: nextElement,\n        direction: this._orderToDirection(order2),\n        from: this._getItemIndex(activeElement),\n        to: nextElementIndex\n      });\n    };\n    const slideEvent = triggerEvent(EVENT_SLIDE);\n    if (slideEvent.defaultPrevented) {\n      return;\n    }\n    if (!activeElement || !nextElement) {\n      return;\n    }\n    const isCycling = Boolean(this._interval);\n    this.pause();\n    this._isSliding = true;\n    this._setActiveIndicatorElement(nextElementIndex);\n    this._activeElement = nextElement;\n    const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;\n    const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;\n    nextElement.classList.add(orderClassName);\n    reflow(nextElement);\n    activeElement.classList.add(directionalClassName);\n    nextElement.classList.add(directionalClassName);\n    const completeCallBack = () => {\n      nextElement.classList.remove(directionalClassName, orderClassName);\n      nextElement.classList.add(CLASS_NAME_ACTIVE$3);\n      activeElement.classList.remove(CLASS_NAME_ACTIVE$3, orderClassName, directionalClassName);\n      this._isSliding = false;\n      triggerEvent(EVENT_SLID);\n    };\n    this._queueCallback(completeCallBack, activeElement, this._isAnimated());\n    if (isCycling) {\n      this.cycle();\n    }\n  }\n  _isAnimated() {\n    return this._element.classList.contains(CLASS_NAME_SLIDE);\n  }\n  _getActive() {\n    return SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);\n  }\n  _getItems() {\n    return SelectorEngine.find(SELECTOR_ITEM, this._element);\n  }\n  _clearInterval() {\n    if (this._interval) {\n      clearInterval(this._interval);\n      this._interval = null;\n    }\n  }\n  _directionToOrder(direction) {\n    if (isRTL()) {\n      return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;\n    }\n    return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;\n  }\n  _orderToDirection(order2) {\n    if (isRTL()) {\n      return order2 === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n    return order2 === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;\n  }\n  // Static\n  static jQueryInterface(config) {\n    return this.each(function() {\n      const data = Carousel.getOrCreateInstance(this, config);\n      if (typeof config === \"number\") {\n        data.to(config);\n        return;\n      }\n      if (typeof config === \"string\") {\n        if (data[config] === void 0 || config.startsWith(\"_\") || config === \"constructor\") {\n          throw new TypeError(`No method named \"${config}\"`);\n        }\n        data[config]();\n      }\n    });\n  }\n};\nconst NAME$k = \"carousel\";\nconst EVENT_SLIDE_BS = \"slide.bs.carousel\";\nconst EVENT_SLID_BS = \"slid.bs.carousel\";\nconst EXTENDED_EVENTS$5 = [\n  { name: \"slide\", parametersToCopy: [\"relatedTarget\", \"direction\", \"from\", \"to\"] },\n  { name: \"slid\", parametersToCopy: [\"relatedTarget\", \"direction\", \"from\", \"to\"] }\n];\nclass Carousel2 extends Carousel$1 {\n  constructor(element2, data) {\n    super(element2, data);\n    this._init();\n    Manipulator$1.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, true);\n    bindCallbackEventsIfNeeded(this.constructor);\n  }\n  dispose() {\n    EventHandler$1.off(this._element, EVENT_SLIDE_BS);\n    EventHandler$1.off(this._element, EVENT_SLID_BS);\n    Manipulator$1.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`);\n    super.dispose();\n  }\n  // Getters\n  static get NAME() {\n    return NAME$k;\n  }\n  // Private\n  _init() {\n    this._bindMdbEvents();\n  }\n  _bindMdbEvents() {\n    EventHandler$1.extend(this._element, EXTENDED_EVENTS$5, NAME$k);\n  }\n}\nconst NAME$j = \"modal\";\nconst DATA_KEY$b = \"bs.modal\";\nconst EVENT_KEY$8 = `.${DATA_KEY$b}`;\nconst ESCAPE_KEY$1 = \"Escape\";\nconst EVENT_HIDE$7 = `hide${EVENT_KEY$8}`;\nconst EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY$8}`;\nconst EVENT_HIDDEN$7 = `hidden${EVENT_KEY$8}`;\nconst EVENT_SHOW$7 = `show${EVENT_KEY$8}`;\nconst EVENT_SHOWN$7 = `shown${EVENT_KEY$8}`;\nconst EVENT_RESIZE = `resize${EVENT_KEY$8}`;\nconst EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY$8}`;\nconst EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY$8}`;\nconst EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY$8}`;\nconst CLASS_NAME_OPEN = \"modal-open\";\nconst CLASS_NAME_FADE$4 = \"fade\";\nconst CLASS_NAME_SHOW$6 = \"show\";\nconst CLASS_NAME_STATIC = \"modal-static\";\nconst SELECTOR_DIALOG = \".modal-dialog\";\nconst SELECTOR_MODAL_BODY = \".modal-body\";\nconst Default$9 = {\n  backdrop: true,\n  focus: true,\n  keyboard: true\n};\nconst DefaultType$9 = {\n  backdrop: \"(boolean|string)\",\n  focus: \"boolean\",\n  keyboard: \"boolean\"\n};\nlet Modal$1 = class Modal extends BaseComponent$1 {\n  constructor(element2, config) {\n    super(element2, config);\n    this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);\n    this._backdrop = this._initializeBackDrop();\n    this._focustrap = this._initializeFocusTrap();\n    this._isShown = false;\n    this._isTransitioning = false;\n    this._scrollBar = new ScrollBarHelper();\n    this._addEventListeners();\n  }\n  // Getters\n  static get Default() {\n    return Default$9;\n  }\n  static get DefaultType() {\n    return DefaultType$9;\n  }\n  static get NAME() {\n    return NAME$j;\n  }\n  // Public\n  toggle(relatedTarget) {\n    return this._isShown ? this.hide() : this.show(relatedTarget);\n  }\n  show(relatedTarget) {\n    if (this._isShown || this._isTransitioning) {\n      return;\n    }\n    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$7, {\n      relatedTarget\n    });\n    if (showEvent.defaultPrevented) {\n      return;\n    }\n    this._isShown = true;\n    this._isTransitioning = true;\n    this._scrollBar.hide();\n    document.body.classList.add(CLASS_NAME_OPEN);\n    this._adjustDialog();\n    this._backdrop.show(() => this._showElement(relatedTarget));\n  }\n  hide() {\n    if (!this._isShown || this._isTransitioning) {\n      return;\n    }\n    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$7);\n    if (hideEvent.defaultPrevented) {\n      return;\n    }\n    this._isShown = false;\n    this._isTransitioning = true;\n    this._focustrap.deactivate();\n    this._element.classList.remove(CLASS_NAME_SHOW$6);\n    this._queueCallback(() => this._hideModal(), this._element, this._isAnimated());\n  }\n  dispose() {\n    EventHandler.off(window, EVENT_KEY$8);\n    EventHandler.off(this._dialog, EVENT_KEY$8);\n    this._backdrop.dispose();\n    this._focustrap.deactivate();\n    super.dispose();\n  }\n  handleUpdate() {\n    this._adjustDialog();\n  }\n  // Private\n  _initializeBackDrop() {\n    return new Backdrop({\n      isVisible: Boolean(this._config.backdrop) && Boolean(!this._config.modalNonInvasive),\n      // 'static' option will be translated to true, and booleans will keep their value,\n      isAnimated: this._isAnimated()\n    });\n  }\n  _initializeFocusTrap() {\n    return new FocusTrap({\n      trapElement: this._element\n    });\n  }\n  _showElement(relatedTarget) {\n    if (!document.body.contains(this._element)) {\n      document.body.append(this._element);\n    }\n    this._element.style.display = \"block\";\n    this._element.removeAttribute(\"aria-hidden\");\n    this._element.setAttribute(\"aria-modal\", true);\n    this._element.setAttribute(\"role\", \"dialog\");\n    this._element.scrollTop = 0;\n    const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);\n    if (modalBody) {\n      modalBody.scrollTop = 0;\n    }\n    reflow(this._element);\n    this._element.classList.add(CLASS_NAME_SHOW$6);\n    const transitionComplete = () => {\n      if (this._config.focus) {\n        this._focustrap.activate();\n      }\n      this._isTransitioning = false;\n      EventHandler.trigger(this._element, EVENT_SHOWN$7, {\n        relatedTarget\n      });\n    };\n    this._queueCallback(transitionComplete, this._dialog, this._isAnimated());\n  }\n  _addEventListeners() {\n    EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, (event) => {\n      if (event.key !== ESCAPE_KEY$1) {\n        return;\n      }\n      if (this._config.keyboard) {\n        this.hide();\n        return;\n      }\n      this._triggerBackdropTransition();\n    });\n    EventHandler.on(window, EVENT_RESIZE, () => {\n      if (this._isShown && !this._isTransitioning) {\n        this._adjustDialog();\n      }\n    });\n    EventHandler.on(this._element, EVENT_MOUSEDOWN_DISMISS, (event) => {\n      EventHandler.one(this._element, EVENT_CLICK_DISMISS, (event2) => {\n        if (this._element !== event.target || this._element !== event2.target) {\n          return;\n        }\n        if (this._config.backdrop === \"static\") {\n          this._triggerBackdropTransition();\n          return;\n        }\n        if (this._config.backdrop) {\n          this.hide();\n        }\n      });\n    });\n  }\n  _hideModal() {\n    this._element.style.display = \"none\";\n    this._element.setAttribute(\"aria-hidden\", true);\n    this._element.removeAttribute(\"aria-modal\");\n    this._element.removeAttribute(\"role\");\n    this._isTransitioning = false;\n    this._backdrop.hide(() => {\n      document.body.classList.remove(CLASS_NAME_OPEN);\n      this._resetAdjustments();\n      this._scrollBar.reset();\n      EventHandler.trigger(this._element, EVENT_HIDDEN$7);\n    });\n  }\n  _isAnimated() {\n    return this._element.classList.contains(CLASS_NAME_FADE$4);\n  }\n  _triggerBackdropTransition() {\n    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);\n    if (hideEvent.defaultPrevented) {\n      return;\n    }\n    const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\n    const initialOverflowY = this._element.style.overflowY;\n    if (initialOverflowY === \"hidden\" || this._element.classList.contains(CLASS_NAME_STATIC)) {\n      return;\n    }\n    if (!isModalOverflowing) {\n      this._element.style.overflowY = \"hidden\";\n    }\n    this._element.classList.add(CLASS_NAME_STATIC);\n    this._queueCallback(() => {\n      this._element.classList.remove(CLASS_NAME_STATIC);\n      this._queueCallback(() => {\n        this._element.style.overflowY = initialOverflowY;\n      }, this._dialog);\n    }, this._dialog);\n    this._element.focus();\n  }\n  /**\n   * The following methods are used to handle overflowing modals\n   */\n  _adjustDialog() {\n    const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\n    const scrollbarWidth = this._scrollBar.getWidth();\n    const isBodyOverflowing = scrollbarWidth > 0;\n    if (isBodyOverflowing && !isModalOverflowing) {\n      const property = isRTL() ? \"paddingLeft\" : \"paddingRight\";\n      this._element.style[property] = `${scrollbarWidth}px`;\n    }\n    if (!isBodyOverflowing && isModalOverflowing) {\n      const property = isRTL() ? \"paddingRight\" : \"paddingLeft\";\n      this._element.style[property] = `${scrollbarWidth}px`;\n    }\n  }\n  _resetAdjustments() {\n    this._element.style.paddingLeft = \"\";\n    this._element.style.paddingRight = \"\";\n  }\n  // Static\n  static jQueryInterface(config, relatedTarget) {\n    return this.each(function() {\n      const data = Modal.getOrCreateInstance(this, config);\n      if (typeof config !== \"string\") {\n        return;\n      }\n      if (typeof data[config] === \"undefined\") {\n        throw new TypeError(`No method named \"${config}\"`);\n      }\n      data[config](relatedTarget);\n    });\n  }\n};\nconst NAME$i = \"modal\";\nconst EVENT_HIDE_BS$5 = \"hide.bs.modal\";\nconst EVENT_HIDE_PREVENTED_BS = \"hidePrevented.bs.modal\";\nconst EVENT_HIDDEN_BS$5 = \"hidden.bs.modal\";\nconst EVENT_SHOW_BS$5 = \"show.bs.modal\";\nconst EVENT_SHOWN_BS$5 = \"shown.bs.modal\";\nconst EXTENDED_EVENTS$4 = [\n  { name: \"show\", parametersToCopy: [\"relatedTarget\"] },\n  { name: \"shown\", parametersToCopy: [\"relatedTarget\"] },\n  { name: \"hide\" },\n  { name: \"hidePrevented\" },\n  { name: \"hidden\" }\n];\nclass Modal2 extends Modal$1 {\n  constructor(element2, data) {\n    super(element2, data);\n    this._init();\n    Manipulator$1.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, true);\n    bindCallbackEventsIfNeeded(this.constructor);\n  }\n  dispose() {\n    EventHandler$1.off(this._element, EVENT_SHOW_BS$5);\n    EventHandler$1.off(this._element, EVENT_SHOWN_BS$5);\n    EventHandler$1.off(this._element, EVENT_HIDE_BS$5);\n    EventHandler$1.off(this._element, EVENT_HIDDEN_BS$5);\n    EventHandler$1.off(this._element, EVENT_HIDE_PREVENTED_BS);\n    Manipulator$1.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`);\n    super.dispose();\n  }\n  // Getters\n  static get NAME() {\n    return NAME$i;\n  }\n  // Private\n  _init() {\n    this._bindMdbEvents();\n  }\n  _bindMdbEvents() {\n    EventHandler$1.extend(this._element, EXTENDED_EVENTS$4, NAME$i);\n  }\n}\nvar top = \"top\";\nvar bottom = \"bottom\";\nvar right = \"right\";\nvar left = \"left\";\nvar auto = \"auto\";\nvar basePlacements = [top, bottom, right, left];\nvar start = \"start\";\nvar end = \"end\";\nvar clippingParents = \"clippingParents\";\nvar viewport = \"viewport\";\nvar popper = \"popper\";\nvar reference = \"reference\";\nvar variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {\n  return acc.concat([placement + \"-\" + start, placement + \"-\" + end]);\n}, []);\nvar placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {\n  return acc.concat([placement, placement + \"-\" + start, placement + \"-\" + end]);\n}, []);\nvar beforeRead = \"beforeRead\";\nvar read = \"read\";\nvar afterRead = \"afterRead\";\nvar beforeMain = \"beforeMain\";\nvar main = \"main\";\nvar afterMain = \"afterMain\";\nvar beforeWrite = \"beforeWrite\";\nvar write = \"write\";\nvar afterWrite = \"afterWrite\";\nvar modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];\nfunction getNodeName(element2) {\n  return element2 ? (element2.nodeName || \"\").toLowerCase() : null;\n}\nfunction getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n  if (node.toString() !== \"[object Window]\") {\n    var ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n  return node;\n}\nfunction isElement(node) {\n  var OwnElement = getWindow(node).Element;\n  return node instanceof OwnElement || node instanceof Element;\n}\nfunction isHTMLElement(node) {\n  var OwnElement = getWindow(node).HTMLElement;\n  return node instanceof OwnElement || node instanceof HTMLElement;\n}\nfunction isShadowRoot(node) {\n  if (typeof ShadowRoot === \"undefined\") {\n    return false;\n  }\n  var OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\nfunction applyStyles(_ref) {\n  var state = _ref.state;\n  Object.keys(state.elements).forEach(function(name) {\n    var style = state.styles[name] || {};\n    var attributes = state.attributes[name] || {};\n    var element2 = state.elements[name];\n    if (!isHTMLElement(element2) || !getNodeName(element2)) {\n      return;\n    }\n    Object.assign(element2.style, style);\n    Object.keys(attributes).forEach(function(name2) {\n      var value = attributes[name2];\n      if (value === false) {\n        element2.removeAttribute(name2);\n      } else {\n        element2.setAttribute(name2, value === true ? \"\" : value);\n      }\n    });\n  });\n}\nfunction effect$2(_ref2) {\n  var state = _ref2.state;\n  var initialStyles = {\n    popper: {\n      position: state.options.strategy,\n      left: \"0\",\n      top: \"0\",\n      margin: \"0\"\n    },\n    arrow: {\n      position: \"absolute\"\n    },\n    reference: {}\n  };\n  Object.assign(state.elements.popper.style, initialStyles.popper);\n  state.styles = initialStyles;\n  if (state.elements.arrow) {\n    Object.assign(state.elements.arrow.style, initialStyles.arrow);\n  }\n  return function() {\n    Object.keys(state.elements).forEach(function(name) {\n      var element2 = state.elements[name];\n      var attributes = state.attributes[name] || {};\n      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);\n      var style = styleProperties.reduce(function(style2, property) {\n        style2[property] = \"\";\n        return style2;\n      }, {});\n      if (!isHTMLElement(element2) || !getNodeName(element2)) {\n        return;\n      }\n      Object.assign(element2.style, style);\n      Object.keys(attributes).forEach(function(attribute) {\n        element2.removeAttribute(attribute);\n      });\n    });\n  };\n}\nconst applyStyles$1 = {\n  name: \"applyStyles\",\n  enabled: true,\n  phase: \"write\",\n  fn: applyStyles,\n  effect: effect$2,\n  requires: [\"computeStyles\"]\n};\nfunction getBasePlacement(placement) {\n  return placement.split(\"-\")[0];\n}\nvar max = Math.max;\nvar min = Math.min;\nvar round = Math.round;\nfunction getUAString() {\n  var uaData = navigator.userAgentData;\n  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {\n    return uaData.brands.map(function(item) {\n      return item.brand + \"/\" + item.version;\n    }).join(\" \");\n  }\n  return navigator.userAgent;\n}\nfunction isLayoutViewport() {\n  return !/^((?!chrome|android).)*safari/i.test(getUAString());\n}\nfunction getBoundingClientRect(element2, includeScale, isFixedStrategy) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  var clientRect = element2.getBoundingClientRect();\n  var scaleX = 1;\n  var scaleY = 1;\n  if (includeScale && isHTMLElement(element2)) {\n    scaleX = element2.offsetWidth > 0 ? round(clientRect.width) / element2.offsetWidth || 1 : 1;\n    scaleY = element2.offsetHeight > 0 ? round(clientRect.height) / element2.offsetHeight || 1 : 1;\n  }\n  var _ref = isElement(element2) ? getWindow(element2) : window, visualViewport = _ref.visualViewport;\n  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;\n  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;\n  var width = clientRect.width / scaleX;\n  var height = clientRect.height / scaleY;\n  return {\n    width,\n    height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n    x,\n    y\n  };\n}\nfunction getLayoutRect(element2) {\n  var clientRect = getBoundingClientRect(element2);\n  var width = element2.offsetWidth;\n  var height = element2.offsetHeight;\n  if (Math.abs(clientRect.width - width) <= 1) {\n    width = clientRect.width;\n  }\n  if (Math.abs(clientRect.height - height) <= 1) {\n    height = clientRect.height;\n  }\n  return {\n    x: element2.offsetLeft,\n    y: element2.offsetTop,\n    width,\n    height\n  };\n}\nfunction contains(parent, child) {\n  var rootNode = child.getRootNode && child.getRootNode();\n  if (parent.contains(child)) {\n    return true;\n  } else if (rootNode && isShadowRoot(rootNode)) {\n    var next = child;\n    do {\n      if (next && parent.isSameNode(next)) {\n        return true;\n      }\n      next = next.parentNode || next.host;\n    } while (next);\n  }\n  return false;\n}\nfunction getComputedStyle$1(element2) {\n  return getWindow(element2).getComputedStyle(element2);\n}\nfunction isTableElement(element2) {\n  return [\"table\", \"td\", \"th\"].indexOf(getNodeName(element2)) >= 0;\n}\nfunction getDocumentElement(element2) {\n  return ((isElement(element2) ? element2.ownerDocument : (\n    // $FlowFixMe[prop-missing]\n    element2.document\n  )) || window.document).documentElement;\n}\nfunction getParentNode(element2) {\n  if (getNodeName(element2) === \"html\") {\n    return element2;\n  }\n  return (\n    // this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // $FlowFixMe[incompatible-return]\n    // $FlowFixMe[prop-missing]\n    element2.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    element2.parentNode || // DOM Element detected\n    (isShadowRoot(element2) ? element2.host : null) || // ShadowRoot detected\n    // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n    getDocumentElement(element2)\n  );\n}\nfunction getTrueOffsetParent(element2) {\n  if (!isHTMLElement(element2) || // https://github.com/popperjs/popper-core/issues/837\n  getComputedStyle$1(element2).position === \"fixed\") {\n    return null;\n  }\n  return element2.offsetParent;\n}\nfunction getContainingBlock(element2) {\n  var isFirefox = /firefox/i.test(getUAString());\n  var isIE = /Trident/i.test(getUAString());\n  if (isIE && isHTMLElement(element2)) {\n    var elementCss = getComputedStyle$1(element2);\n    if (elementCss.position === \"fixed\") {\n      return null;\n    }\n  }\n  var currentNode = getParentNode(element2);\n  if (isShadowRoot(currentNode)) {\n    currentNode = currentNode.host;\n  }\n  while (isHTMLElement(currentNode) && [\"html\", \"body\"].indexOf(getNodeName(currentNode)) < 0) {\n    var css = getComputedStyle$1(currentNode);\n    if (css.transform !== \"none\" || css.perspective !== \"none\" || css.contain === \"paint\" || [\"transform\", \"perspective\"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === \"filter\" || isFirefox && css.filter && css.filter !== \"none\") {\n      return currentNode;\n    } else {\n      currentNode = currentNode.parentNode;\n    }\n  }\n  return null;\n}\nfunction getOffsetParent(element2) {\n  var window2 = getWindow(element2);\n  var offsetParent = getTrueOffsetParent(element2);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === \"static\") {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n  if (offsetParent && (getNodeName(offsetParent) === \"html\" || getNodeName(offsetParent) === \"body\" && getComputedStyle$1(offsetParent).position === \"static\")) {\n    return window2;\n  }\n  return offsetParent || getContainingBlock(element2) || window2;\n}\nfunction getMainAxisFromPlacement(placement) {\n  return [\"top\", \"bottom\"].indexOf(placement) >= 0 ? \"x\" : \"y\";\n}\nfunction within(min$1, value, max$1) {\n  return max(min$1, min(value, max$1));\n}\nfunction withinMaxClamp(min2, value, max2) {\n  var v = within(min2, value, max2);\n  return v > max2 ? max2 : v;\n}\nfunction getFreshSideObject() {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n}\nfunction mergePaddingObject(paddingObject) {\n  return Object.assign({}, getFreshSideObject(), paddingObject);\n}\nfunction expandToHashMap(value, keys) {\n  return keys.reduce(function(hashMap, key) {\n    hashMap[key] = value;\n    return hashMap;\n  }, {});\n}\nvar toPaddingObject = function toPaddingObject2(padding, state) {\n  padding = typeof padding === \"function\" ? padding(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : padding;\n  return mergePaddingObject(typeof padding !== \"number\" ? padding : expandToHashMap(padding, basePlacements));\n};\nfunction arrow(_ref) {\n  var _state$modifiersData$;\n  var state = _ref.state, name = _ref.name, options = _ref.options;\n  var arrowElement = state.elements.arrow;\n  var popperOffsets2 = state.modifiersData.popperOffsets;\n  var basePlacement = getBasePlacement(state.placement);\n  var axis = getMainAxisFromPlacement(basePlacement);\n  var isVertical = [left, right].indexOf(basePlacement) >= 0;\n  var len = isVertical ? \"height\" : \"width\";\n  if (!arrowElement || !popperOffsets2) {\n    return;\n  }\n  var paddingObject = toPaddingObject(options.padding, state);\n  var arrowRect = getLayoutRect(arrowElement);\n  var minProp = axis === \"y\" ? top : left;\n  var maxProp = axis === \"y\" ? bottom : right;\n  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];\n  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];\n  var arrowOffsetParent = getOffsetParent(arrowElement);\n  var clientSize = arrowOffsetParent ? axis === \"y\" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n  var centerToReference = endDiff / 2 - startDiff / 2;\n  var min2 = paddingObject[minProp];\n  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];\n  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n  var offset2 = within(min2, center, max2);\n  var axisProp = axis;\n  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);\n}\nfunction effect$1(_ref2) {\n  var state = _ref2.state, options = _ref2.options;\n  var _options$element = options.element, arrowElement = _options$element === void 0 ? \"[data-popper-arrow]\" : _options$element;\n  if (arrowElement == null) {\n    return;\n  }\n  if (typeof arrowElement === \"string\") {\n    arrowElement = state.elements.popper.querySelector(arrowElement);\n    if (!arrowElement) {\n      return;\n    }\n  }\n  if (!contains(state.elements.popper, arrowElement)) {\n    return;\n  }\n  state.elements.arrow = arrowElement;\n}\nconst arrow$1 = {\n  name: \"arrow\",\n  enabled: true,\n  phase: \"main\",\n  fn: arrow,\n  effect: effect$1,\n  requires: [\"popperOffsets\"],\n  requiresIfExists: [\"preventOverflow\"]\n};\nfunction getVariation(placement) {\n  return placement.split(\"-\")[1];\n}\nvar unsetSides = {\n  top: \"auto\",\n  right: \"auto\",\n  bottom: \"auto\",\n  left: \"auto\"\n};\nfunction roundOffsetsByDPR(_ref, win) {\n  var x = _ref.x, y = _ref.y;\n  var dpr = win.devicePixelRatio || 1;\n  return {\n    x: round(x * dpr) / dpr || 0,\n    y: round(y * dpr) / dpr || 0\n  };\n}\nfunction mapToStyles(_ref2) {\n  var _Object$assign2;\n  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;\n  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;\n  var _ref3 = typeof roundOffsets === \"function\" ? roundOffsets({\n    x,\n    y\n  }) : {\n    x,\n    y\n  };\n  x = _ref3.x;\n  y = _ref3.y;\n  var hasX = offsets.hasOwnProperty(\"x\");\n  var hasY = offsets.hasOwnProperty(\"y\");\n  var sideX = left;\n  var sideY = top;\n  var win = window;\n  if (adaptive) {\n    var offsetParent = getOffsetParent(popper2);\n    var heightProp = \"clientHeight\";\n    var widthProp = \"clientWidth\";\n    if (offsetParent === getWindow(popper2)) {\n      offsetParent = getDocumentElement(popper2);\n      if (getComputedStyle$1(offsetParent).position !== \"static\" && position === \"absolute\") {\n        heightProp = \"scrollHeight\";\n        widthProp = \"scrollWidth\";\n      }\n    }\n    offsetParent = offsetParent;\n    if (placement === top || (placement === left || placement === right) && variation === end) {\n      sideY = bottom;\n      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (\n        // $FlowFixMe[prop-missing]\n        offsetParent[heightProp]\n      );\n      y -= offsetY - popperRect.height;\n      y *= gpuAcceleration ? 1 : -1;\n    }\n    if (placement === left || (placement === top || placement === bottom) && variation === end) {\n      sideX = right;\n      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (\n        // $FlowFixMe[prop-missing]\n        offsetParent[widthProp]\n      );\n      x -= offsetX - popperRect.width;\n      x *= gpuAcceleration ? 1 : -1;\n    }\n  }\n  var commonStyles = Object.assign({\n    position\n  }, adaptive && unsetSides);\n  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({\n    x,\n    y\n  }, getWindow(popper2)) : {\n    x,\n    y\n  };\n  x = _ref4.x;\n  y = _ref4.y;\n  if (gpuAcceleration) {\n    var _Object$assign;\n    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? \"0\" : \"\", _Object$assign[sideX] = hasX ? \"0\" : \"\", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? \"translate(\" + x + \"px, \" + y + \"px)\" : \"translate3d(\" + x + \"px, \" + y + \"px, 0)\", _Object$assign));\n  }\n  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \"px\" : \"\", _Object$assign2[sideX] = hasX ? x + \"px\" : \"\", _Object$assign2.transform = \"\", _Object$assign2));\n}\nfunction computeStyles(_ref5) {\n  var state = _ref5.state, options = _ref5.options;\n  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;\n  var commonStyles = {\n    placement: getBasePlacement(state.placement),\n    variation: getVariation(state.placement),\n    popper: state.elements.popper,\n    popperRect: state.rects.popper,\n    gpuAcceleration,\n    isFixed: state.options.strategy === \"fixed\"\n  };\n  if (state.modifiersData.popperOffsets != null) {\n    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {\n      offsets: state.modifiersData.popperOffsets,\n      position: state.options.strategy,\n      adaptive,\n      roundOffsets\n    })));\n  }\n  if (state.modifiersData.arrow != null) {\n    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {\n      offsets: state.modifiersData.arrow,\n      position: \"absolute\",\n      adaptive: false,\n      roundOffsets\n    })));\n  }\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    \"data-popper-placement\": state.placement\n  });\n}\nconst computeStyles$1 = {\n  name: \"computeStyles\",\n  enabled: true,\n  phase: \"beforeWrite\",\n  fn: computeStyles,\n  data: {}\n};\nvar passive = {\n  passive: true\n};\nfunction effect(_ref) {\n  var state = _ref.state, instance = _ref.instance, options = _ref.options;\n  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;\n  var window2 = getWindow(state.elements.popper);\n  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\n  if (scroll) {\n    scrollParents.forEach(function(scrollParent) {\n      scrollParent.addEventListener(\"scroll\", instance.update, passive);\n    });\n  }\n  if (resize) {\n    window2.addEventListener(\"resize\", instance.update, passive);\n  }\n  return function() {\n    if (scroll) {\n      scrollParents.forEach(function(scrollParent) {\n        scrollParent.removeEventListener(\"scroll\", instance.update, passive);\n      });\n    }\n    if (resize) {\n      window2.removeEventListener(\"resize\", instance.update, passive);\n    }\n  };\n}\nconst eventListeners = {\n  name: \"eventListeners\",\n  enabled: true,\n  phase: \"write\",\n  fn: function fn() {\n  },\n  effect,\n  data: {}\n};\nvar hash$1 = {\n  left: \"right\",\n  right: \"left\",\n  bottom: \"top\",\n  top: \"bottom\"\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, function(matched) {\n    return hash$1[matched];\n  });\n}\nvar hash = {\n  start: \"end\",\n  end: \"start\"\n};\nfunction getOppositeVariationPlacement(placement) {\n  return placement.replace(/start|end/g, function(matched) {\n    return hash[matched];\n  });\n}\nfunction getWindowScroll(node) {\n  var win = getWindow(node);\n  var scrollLeft = win.pageXOffset;\n  var scrollTop = win.pageYOffset;\n  return {\n    scrollLeft,\n    scrollTop\n  };\n}\nfunction getWindowScrollBarX(element2) {\n  return getBoundingClientRect(getDocumentElement(element2)).left + getWindowScroll(element2).scrollLeft;\n}\nfunction getViewportRect(element2, strategy) {\n  var win = getWindow(element2);\n  var html = getDocumentElement(element2);\n  var visualViewport = win.visualViewport;\n  var width = html.clientWidth;\n  var height = html.clientHeight;\n  var x = 0;\n  var y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    var layoutViewport = isLayoutViewport();\n    if (layoutViewport || !layoutViewport && strategy === \"fixed\") {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x: x + getWindowScrollBarX(element2),\n    y\n  };\n}\nfunction getDocumentRect(element2) {\n  var _element$ownerDocumen;\n  var html = getDocumentElement(element2);\n  var winScroll = getWindowScroll(element2);\n  var body = (_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  var x = -winScroll.scrollLeft + getWindowScrollBarX(element2);\n  var y = -winScroll.scrollTop;\n  if (getComputedStyle$1(body || html).direction === \"rtl\") {\n    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction isScrollParent(element2) {\n  var _getComputedStyle = getComputedStyle$1(element2), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}\nfunction getScrollParent(node) {\n  if ([\"html\", \"body\", \"#document\"].indexOf(getNodeName(node)) >= 0) {\n    return node.ownerDocument.body;\n  }\n  if (isHTMLElement(node) && isScrollParent(node)) {\n    return node;\n  }\n  return getScrollParent(getParentNode(node));\n}\nfunction listScrollParents(element2, list) {\n  var _element$ownerDocumen;\n  if (list === void 0) {\n    list = [];\n  }\n  var scrollParent = getScrollParent(element2);\n  var isBody = scrollParent === ((_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);\n  var win = getWindow(scrollParent);\n  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\n  var updatedList = list.concat(target);\n  return isBody ? updatedList : (\n    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here\n    updatedList.concat(listScrollParents(getParentNode(target)))\n  );\n}\nfunction rectToClientRect(rect) {\n  return Object.assign({}, rect, {\n    left: rect.x,\n    top: rect.y,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  });\n}\nfunction getInnerBoundingClientRect(element2, strategy) {\n  var rect = getBoundingClientRect(element2, false, strategy === \"fixed\");\n  rect.top = rect.top + element2.clientTop;\n  rect.left = rect.left + element2.clientLeft;\n  rect.bottom = rect.top + element2.clientHeight;\n  rect.right = rect.left + element2.clientWidth;\n  rect.width = element2.clientWidth;\n  rect.height = element2.clientHeight;\n  rect.x = rect.left;\n  rect.y = rect.top;\n  return rect;\n}\nfunction getClientRectFromMixedType(element2, clippingParent, strategy) {\n  return clippingParent === viewport ? rectToClientRect(getViewportRect(element2, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element2)));\n}\nfunction getClippingParents(element2) {\n  var clippingParents2 = listScrollParents(getParentNode(element2));\n  var canEscapeClipping = [\"absolute\", \"fixed\"].indexOf(getComputedStyle$1(element2).position) >= 0;\n  var clipperElement = canEscapeClipping && isHTMLElement(element2) ? getOffsetParent(element2) : element2;\n  if (!isElement(clipperElement)) {\n    return [];\n  }\n  return clippingParents2.filter(function(clippingParent) {\n    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== \"body\";\n  });\n}\nfunction getClippingRect(element2, boundary, rootBoundary, strategy) {\n  var mainClippingParents = boundary === \"clippingParents\" ? getClippingParents(element2) : [].concat(boundary);\n  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);\n  var firstClippingParent = clippingParents2[0];\n  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {\n    var rect = getClientRectFromMixedType(element2, clippingParent, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromMixedType(element2, firstClippingParent, strategy));\n  clippingRect.width = clippingRect.right - clippingRect.left;\n  clippingRect.height = clippingRect.bottom - clippingRect.top;\n  clippingRect.x = clippingRect.left;\n  clippingRect.y = clippingRect.top;\n  return clippingRect;\n}\nfunction computeOffsets(_ref) {\n  var reference2 = _ref.reference, element2 = _ref.element, placement = _ref.placement;\n  var basePlacement = placement ? getBasePlacement(placement) : null;\n  var variation = placement ? getVariation(placement) : null;\n  var commonX = reference2.x + reference2.width / 2 - element2.width / 2;\n  var commonY = reference2.y + reference2.height / 2 - element2.height / 2;\n  var offsets;\n  switch (basePlacement) {\n    case top:\n      offsets = {\n        x: commonX,\n        y: reference2.y - element2.height\n      };\n      break;\n    case bottom:\n      offsets = {\n        x: commonX,\n        y: reference2.y + reference2.height\n      };\n      break;\n    case right:\n      offsets = {\n        x: reference2.x + reference2.width,\n        y: commonY\n      };\n      break;\n    case left:\n      offsets = {\n        x: reference2.x - element2.width,\n        y: commonY\n      };\n      break;\n    default:\n      offsets = {\n        x: reference2.x,\n        y: reference2.y\n      };\n  }\n  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;\n  if (mainAxis != null) {\n    var len = mainAxis === \"y\" ? \"height\" : \"width\";\n    switch (variation) {\n      case start:\n        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element2[len] / 2);\n        break;\n      case end:\n        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element2[len] / 2);\n        break;\n    }\n  }\n  return offsets;\n}\nfunction detectOverflow(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;\n  var paddingObject = mergePaddingObject(typeof padding !== \"number\" ? padding : expandToHashMap(padding, basePlacements));\n  var altContext = elementContext === popper ? reference : popper;\n  var popperRect = state.rects.popper;\n  var element2 = state.elements[altBoundary ? altContext : elementContext];\n  var clippingClientRect = getClippingRect(isElement(element2) ? element2 : element2.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);\n  var referenceClientRect = getBoundingClientRect(state.elements.reference);\n  var popperOffsets2 = computeOffsets({\n    reference: referenceClientRect,\n    element: popperRect,\n    strategy: \"absolute\",\n    placement\n  });\n  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));\n  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;\n  var overflowOffsets = {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n  var offsetData = state.modifiersData.offset;\n  if (elementContext === popper && offsetData) {\n    var offset2 = offsetData[placement];\n    Object.keys(overflowOffsets).forEach(function(key) {\n      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n      var axis = [top, bottom].indexOf(key) >= 0 ? \"y\" : \"x\";\n      overflowOffsets[key] += offset2[axis] * multiply;\n    });\n  }\n  return overflowOffsets;\n}\nfunction computeAutoPlacement(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;\n  var variation = getVariation(placement);\n  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {\n    return getVariation(placement2) === variation;\n  }) : basePlacements;\n  var allowedPlacements = placements$1.filter(function(placement2) {\n    return allowedAutoPlacements.indexOf(placement2) >= 0;\n  });\n  if (allowedPlacements.length === 0) {\n    allowedPlacements = placements$1;\n  }\n  var overflows = allowedPlacements.reduce(function(acc, placement2) {\n    acc[placement2] = detectOverflow(state, {\n      placement: placement2,\n      boundary,\n      rootBoundary,\n      padding\n    })[getBasePlacement(placement2)];\n    return acc;\n  }, {});\n  return Object.keys(overflows).sort(function(a, b) {\n    return overflows[a] - overflows[b];\n  });\n}\nfunction getExpandedFallbackPlacements(placement) {\n  if (getBasePlacement(placement) === auto) {\n    return [];\n  }\n  var oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];\n}\nfunction flip(_ref) {\n  var state = _ref.state, options = _ref.options, name = _ref.name;\n  if (state.modifiersData[name]._skip) {\n    return;\n  }\n  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;\n  var preferredPlacement = state.options.placement;\n  var basePlacement = getBasePlacement(preferredPlacement);\n  var isBasePlacement = basePlacement === preferredPlacement;\n  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\n  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {\n    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {\n      placement: placement2,\n      boundary,\n      rootBoundary,\n      padding,\n      flipVariations,\n      allowedAutoPlacements\n    }) : placement2);\n  }, []);\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var checksMap = /* @__PURE__ */ new Map();\n  var makeFallbackChecks = true;\n  var firstFittingPlacement = placements2[0];\n  for (var i = 0; i < placements2.length; i++) {\n    var placement = placements2[i];\n    var _basePlacement = getBasePlacement(placement);\n    var isStartVariation = getVariation(placement) === start;\n    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;\n    var len = isVertical ? \"width\" : \"height\";\n    var overflow = detectOverflow(state, {\n      placement,\n      boundary,\n      rootBoundary,\n      altBoundary,\n      padding\n    });\n    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;\n    if (referenceRect[len] > popperRect[len]) {\n      mainVariationSide = getOppositePlacement(mainVariationSide);\n    }\n    var altVariationSide = getOppositePlacement(mainVariationSide);\n    var checks = [];\n    if (checkMainAxis) {\n      checks.push(overflow[_basePlacement] <= 0);\n    }\n    if (checkAltAxis) {\n      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n    }\n    if (checks.every(function(check) {\n      return check;\n    })) {\n      firstFittingPlacement = placement;\n      makeFallbackChecks = false;\n      break;\n    }\n    checksMap.set(placement, checks);\n  }\n  if (makeFallbackChecks) {\n    var numberOfChecks = flipVariations ? 3 : 1;\n    var _loop = function _loop2(_i2) {\n      var fittingPlacement = placements2.find(function(placement2) {\n        var checks2 = checksMap.get(placement2);\n        if (checks2) {\n          return checks2.slice(0, _i2).every(function(check) {\n            return check;\n          });\n        }\n      });\n      if (fittingPlacement) {\n        firstFittingPlacement = fittingPlacement;\n        return \"break\";\n      }\n    };\n    for (var _i = numberOfChecks; _i > 0; _i--) {\n      var _ret = _loop(_i);\n      if (_ret === \"break\")\n        break;\n    }\n  }\n  if (state.placement !== firstFittingPlacement) {\n    state.modifiersData[name]._skip = true;\n    state.placement = firstFittingPlacement;\n    state.reset = true;\n  }\n}\nconst flip$1 = {\n  name: \"flip\",\n  enabled: true,\n  phase: \"main\",\n  fn: flip,\n  requiresIfExists: [\"offset\"],\n  data: {\n    _skip: false\n  }\n};\nfunction getSideOffsets(overflow, rect, preventedOffsets) {\n  if (preventedOffsets === void 0) {\n    preventedOffsets = {\n      x: 0,\n      y: 0\n    };\n  }\n  return {\n    top: overflow.top - rect.height - preventedOffsets.y,\n    right: overflow.right - rect.width + preventedOffsets.x,\n    bottom: overflow.bottom - rect.height + preventedOffsets.y,\n    left: overflow.left - rect.width - preventedOffsets.x\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return [top, right, bottom, left].some(function(side) {\n    return overflow[side] >= 0;\n  });\n}\nfunction hide(_ref) {\n  var state = _ref.state, name = _ref.name;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var preventedOffsets = state.modifiersData.preventOverflow;\n  var referenceOverflow = detectOverflow(state, {\n    elementContext: \"reference\"\n  });\n  var popperAltOverflow = detectOverflow(state, {\n    altBoundary: true\n  });\n  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\n  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\n  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\n  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\n  state.modifiersData[name] = {\n    referenceClippingOffsets,\n    popperEscapeOffsets,\n    isReferenceHidden,\n    hasPopperEscaped\n  };\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    \"data-popper-reference-hidden\": isReferenceHidden,\n    \"data-popper-escaped\": hasPopperEscaped\n  });\n}\nconst hide$1 = {\n  name: \"hide\",\n  enabled: true,\n  phase: \"main\",\n  requiresIfExists: [\"preventOverflow\"],\n  fn: hide\n};\nfunction distanceAndSkiddingToXY(placement, rects, offset2) {\n  var basePlacement = getBasePlacement(placement);\n  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;\n  var _ref = typeof offset2 === \"function\" ? offset2(Object.assign({}, rects, {\n    placement\n  })) : offset2, skidding = _ref[0], distance = _ref[1];\n  skidding = skidding || 0;\n  distance = (distance || 0) * invertDistance;\n  return [left, right].indexOf(basePlacement) >= 0 ? {\n    x: distance,\n    y: skidding\n  } : {\n    x: skidding,\n    y: distance\n  };\n}\nfunction offset(_ref2) {\n  var state = _ref2.state, options = _ref2.options, name = _ref2.name;\n  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;\n  var data = placements.reduce(function(acc, placement) {\n    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);\n    return acc;\n  }, {});\n  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;\n  if (state.modifiersData.popperOffsets != null) {\n    state.modifiersData.popperOffsets.x += x;\n    state.modifiersData.popperOffsets.y += y;\n  }\n  state.modifiersData[name] = data;\n}\nconst offset$1 = {\n  name: \"offset\",\n  enabled: true,\n  phase: \"main\",\n  requires: [\"popperOffsets\"],\n  fn: offset\n};\nfunction popperOffsets(_ref) {\n  var state = _ref.state, name = _ref.name;\n  state.modifiersData[name] = computeOffsets({\n    reference: state.rects.reference,\n    element: state.rects.popper,\n    strategy: \"absolute\",\n    placement: state.placement\n  });\n}\nconst popperOffsets$1 = {\n  name: \"popperOffsets\",\n  enabled: true,\n  phase: \"read\",\n  fn: popperOffsets,\n  data: {}\n};\nfunction getAltAxis(axis) {\n  return axis === \"x\" ? \"y\" : \"x\";\n}\nfunction preventOverflow(_ref) {\n  var state = _ref.state, options = _ref.options, name = _ref.name;\n  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n  var overflow = detectOverflow(state, {\n    boundary,\n    rootBoundary,\n    padding,\n    altBoundary\n  });\n  var basePlacement = getBasePlacement(state.placement);\n  var variation = getVariation(state.placement);\n  var isBasePlacement = !variation;\n  var mainAxis = getMainAxisFromPlacement(basePlacement);\n  var altAxis = getAltAxis(mainAxis);\n  var popperOffsets2 = state.modifiersData.popperOffsets;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var tetherOffsetValue = typeof tetherOffset === \"function\" ? tetherOffset(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : tetherOffset;\n  var normalizedTetherOffsetValue = typeof tetherOffsetValue === \"number\" ? {\n    mainAxis: tetherOffsetValue,\n    altAxis: tetherOffsetValue\n  } : Object.assign({\n    mainAxis: 0,\n    altAxis: 0\n  }, tetherOffsetValue);\n  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;\n  var data = {\n    x: 0,\n    y: 0\n  };\n  if (!popperOffsets2) {\n    return;\n  }\n  if (checkMainAxis) {\n    var _offsetModifierState$;\n    var mainSide = mainAxis === \"y\" ? top : left;\n    var altSide = mainAxis === \"y\" ? bottom : right;\n    var len = mainAxis === \"y\" ? \"height\" : \"width\";\n    var offset2 = popperOffsets2[mainAxis];\n    var min$1 = offset2 + overflow[mainSide];\n    var max$1 = offset2 - overflow[altSide];\n    var additive = tether ? -popperRect[len] / 2 : 0;\n    var minLen = variation === start ? referenceRect[len] : popperRect[len];\n    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];\n    var arrowElement = state.elements.arrow;\n    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n      width: 0,\n      height: 0\n    };\n    var arrowPaddingObject = state.modifiersData[\"arrow#persistent\"] ? state.modifiersData[\"arrow#persistent\"].padding : getFreshSideObject();\n    var arrowPaddingMin = arrowPaddingObject[mainSide];\n    var arrowPaddingMax = arrowPaddingObject[altSide];\n    var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;\n    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;\n    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n    var clientOffset = arrowOffsetParent ? mainAxis === \"y\" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;\n    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;\n    var tetherMax = offset2 + maxOffset - offsetModifierValue;\n    var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset2, tether ? max(max$1, tetherMax) : max$1);\n    popperOffsets2[mainAxis] = preventedOffset;\n    data[mainAxis] = preventedOffset - offset2;\n  }\n  if (checkAltAxis) {\n    var _offsetModifierState$2;\n    var _mainSide = mainAxis === \"x\" ? top : left;\n    var _altSide = mainAxis === \"x\" ? bottom : right;\n    var _offset = popperOffsets2[altAxis];\n    var _len = altAxis === \"y\" ? \"height\" : \"width\";\n    var _min = _offset + overflow[_mainSide];\n    var _max = _offset - overflow[_altSide];\n    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;\n    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;\n    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;\n    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;\n    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);\n    popperOffsets2[altAxis] = _preventedOffset;\n    data[altAxis] = _preventedOffset - _offset;\n  }\n  state.modifiersData[name] = data;\n}\nconst preventOverflow$1 = {\n  name: \"preventOverflow\",\n  enabled: true,\n  phase: \"main\",\n  fn: preventOverflow,\n  requiresIfExists: [\"offset\"]\n};\nfunction getHTMLElementScroll(element2) {\n  return {\n    scrollLeft: element2.scrollLeft,\n    scrollTop: element2.scrollTop\n  };\n}\nfunction getNodeScroll(node) {\n  if (node === getWindow(node) || !isHTMLElement(node)) {\n    return getWindowScroll(node);\n  } else {\n    return getHTMLElementScroll(node);\n  }\n}\nfunction isElementScaled(element2) {\n  var rect = element2.getBoundingClientRect();\n  var scaleX = round(rect.width) / element2.offsetWidth || 1;\n  var scaleY = round(rect.height) / element2.offsetHeight || 1;\n  return scaleX !== 1 || scaleY !== 1;\n}\nfunction getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  var isOffsetParentAnElement = isHTMLElement(offsetParent);\n  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);\n  var documentElement = getDocumentElement(offsetParent);\n  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);\n  var scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  var offsets = {\n    x: 0,\n    y: 0\n  };\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== \"body\" || // https://github.com/popperjs/popper-core/issues/1078\n    isScrollParent(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      offsets = getBoundingClientRect(offsetParent, true);\n      offsets.x += offsetParent.clientLeft;\n      offsets.y += offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\nfunction order(modifiers) {\n  var map = /* @__PURE__ */ new Map();\n  var visited = /* @__PURE__ */ new Set();\n  var result = [];\n  modifiers.forEach(function(modifier) {\n    map.set(modifier.name, modifier);\n  });\n  function sort(modifier) {\n    visited.add(modifier.name);\n    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\n    requires.forEach(function(dep) {\n      if (!visited.has(dep)) {\n        var depModifier = map.get(dep);\n        if (depModifier) {\n          sort(depModifier);\n        }\n      }\n    });\n    result.push(modifier);\n  }\n  modifiers.forEach(function(modifier) {\n    if (!visited.has(modifier.name)) {\n      sort(modifier);\n    }\n  });\n  return result;\n}\nfunction orderModifiers(modifiers) {\n  var orderedModifiers = order(modifiers);\n  return modifierPhases.reduce(function(acc, phase) {\n    return acc.concat(orderedModifiers.filter(function(modifier) {\n      return modifier.phase === phase;\n    }));\n  }, []);\n}\nfunction debounce(fn2) {\n  var pending;\n  return function() {\n    if (!pending) {\n      pending = new Promise(function(resolve) {\n        Promise.resolve().then(function() {\n          pending = void 0;\n          resolve(fn2());\n        });\n      });\n    }\n    return pending;\n  };\n}\nfunction mergeByName(modifiers) {\n  var merged = modifiers.reduce(function(merged2, current) {\n    var existing = merged2[current.name];\n    merged2[current.name] = existing ? Object.assign({}, existing, current, {\n      options: Object.assign({}, existing.options, current.options),\n      data: Object.assign({}, existing.data, current.data)\n    }) : current;\n    return merged2;\n  }, {});\n  return Object.keys(merged).map(function(key) {\n    return merged[key];\n  });\n}\nvar DEFAULT_OPTIONS = {\n  placement: \"bottom\",\n  modifiers: [],\n  strategy: \"absolute\"\n};\nfunction areValidElements() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  return !args.some(function(element2) {\n    return !(element2 && typeof element2.getBoundingClientRect === \"function\");\n  });\n}\nfunction popperGenerator(generatorOptions) {\n  if (generatorOptions === void 0) {\n    generatorOptions = {};\n  }\n  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n  return function createPopper2(reference2, popper2, options) {\n    if (options === void 0) {\n      options = defaultOptions;\n    }\n    var state = {\n      placement: \"bottom\",\n      orderedModifiers: [],\n      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\n      modifiersData: {},\n      elements: {\n        reference: reference2,\n        popper: popper2\n      },\n      attributes: {},\n      styles: {}\n    };\n    var effectCleanupFns = [];\n    var isDestroyed = false;\n    var instance = {\n      state,\n      setOptions: function setOptions(setOptionsAction) {\n        var options2 = typeof setOptionsAction === \"function\" ? setOptionsAction(state.options) : setOptionsAction;\n        cleanupModifierEffects();\n        state.options = Object.assign({}, defaultOptions, state.options, options2);\n        state.scrollParents = {\n          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],\n          popper: listScrollParents(popper2)\n        };\n        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));\n        state.orderedModifiers = orderedModifiers.filter(function(m) {\n          return m.enabled;\n        });\n        runModifierEffects();\n        return instance.update();\n      },\n      // Sync update  it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate: function forceUpdate() {\n        if (isDestroyed) {\n          return;\n        }\n        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;\n        if (!areValidElements(reference3, popper3)) {\n          return;\n        }\n        state.rects = {\n          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === \"fixed\"),\n          popper: getLayoutRect(popper3)\n        };\n        state.reset = false;\n        state.placement = state.options.placement;\n        state.orderedModifiers.forEach(function(modifier) {\n          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n        });\n        for (var index = 0; index < state.orderedModifiers.length; index++) {\n          if (state.reset === true) {\n            state.reset = false;\n            index = -1;\n            continue;\n          }\n          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;\n          if (typeof fn2 === \"function\") {\n            state = fn2({\n              state,\n              options: _options,\n              name,\n              instance\n            }) || state;\n          }\n        }\n      },\n      // Async and optimistically optimized update  it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: debounce(function() {\n        return new Promise(function(resolve) {\n          instance.forceUpdate();\n          resolve(state);\n        });\n      }),\n      destroy: function destroy() {\n        cleanupModifierEffects();\n        isDestroyed = true;\n      }\n    };\n    if (!areValidElements(reference2, popper2)) {\n      return instance;\n    }\n    instance.setOptions(options).then(function(state2) {\n      if (!isDestroyed && options.onFirstUpdate) {\n        options.onFirstUpdate(state2);\n      }\n    });\n    function runModifierEffects() {\n      state.orderedModifiers.forEach(function(_ref) {\n        var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect2 = _ref.effect;\n        if (typeof effect2 === \"function\") {\n          var cleanupFn = effect2({\n            state,\n            name,\n            instance,\n            options: options2\n          });\n          var noopFn = function noopFn2() {\n          };\n          effectCleanupFns.push(cleanupFn || noopFn);\n        }\n      });\n    }\n    function cleanupModifierEffects() {\n      effectCleanupFns.forEach(function(fn2) {\n        return fn2();\n      });\n      effectCleanupFns = [];\n    }\n    return instance;\n  };\n}\nvar createPopper$2 = /* @__PURE__ */ popperGenerator();\nvar defaultModifiers$1 = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1];\nvar createPopper$1 = /* @__PURE__ */ popperGenerator({\n  defaultModifiers: defaultModifiers$1\n});\nvar defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];\nvar createPopper = /* @__PURE__ */ popperGenerator({\n  defaultModifiers\n});\nconst Popper = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  afterMain,\n  afterRead,\n  afterWrite,\n  applyStyles: applyStyles$1,\n  arrow: arrow$1,\n  auto,\n  basePlacements,\n  beforeMain,\n  beforeRead,\n  beforeWrite,\n  bottom,\n  clippingParents,\n  computeStyles: computeStyles$1,\n  createPopper,\n  createPopperBase: createPopper$2,\n  createPopperLite: createPopper$1,\n  detectOverflow,\n  end,\n  eventListeners,\n  flip: flip$1,\n  hide: hide$1,\n  left,\n  main,\n  modifierPhases,\n  offset: offset$1,\n  placements,\n  popper,\n  popperGenerator,\n  popperOffsets: popperOffsets$1,\n  preventOverflow: preventOverflow$1,\n  read,\n  reference,\n  right,\n  start,\n  top,\n  variationPlacements,\n  viewport,\n  write\n}, Symbol.toStringTag, { value: \"Module\" }));\nconst ARIA_ATTRIBUTE_PATTERN = /^aria-[\\w-]*$/i;\nconst DefaultAllowlist = {\n  // Global attributes allowed on any supplied element below.\n  \"*\": [\"class\", \"dir\", \"id\", \"lang\", \"role\", ARIA_ATTRIBUTE_PATTERN],\n  a: [\"target\", \"href\", \"title\", \"rel\"],\n  area: [],\n  b: [],\n  br: [],\n  col: [],\n  code: [],\n  dd: [],\n  div: [],\n  dl: [],\n  dt: [],\n  em: [],\n  hr: [],\n  h1: [],\n  h2: [],\n  h3: [],\n  h4: [],\n  h5: [],\n  h6: [],\n  i: [],\n  img: [\"src\", \"srcset\", \"alt\", \"title\", \"width\", \"height\"],\n  li: [],\n  ol: [],\n  p: [],\n  pre: [],\n  s: [],\n  small: [],\n  span: [],\n  sub: [],\n  sup: [],\n  strong: [],\n  u: [],\n  ul: []\n};\nconst uriAttributes = /* @__PURE__ */ new Set([\n  \"background\",\n  \"cite\",\n  \"href\",\n  \"itemtype\",\n  \"longdesc\",\n  \"poster\",\n  \"src\",\n  \"xlink:href\"\n]);\nconst SAFE_URL_PATTERN = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i;\nconst allowedAttribute = (attribute, allowedAttributeList) => {\n  const attributeName = attribute.nodeName.toLowerCase();\n  if (allowedAttributeList.includes(attributeName)) {\n    if (uriAttributes.has(attributeName)) {\n      return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue));\n    }\n    return true;\n  }\n  return allowedAttributeList.filter((attributeRegex) => attributeRegex instanceof RegExp).some((regex) => regex.test(attributeName));\n};\nfunction sanitizeHtml(unsafeHtml, allowList, sanitizeFunction) {\n  if (!unsafeHtml.length) {\n    return unsafeHtml;\n  }\n  if (sanitizeFunction && typeof sanitizeFunction === \"function\") {\n    return sanitizeFunction(unsafeHtml);\n  }\n  const domParser = new window.DOMParser();\n  const createdDocument = domParser.parseFromString(unsafeHtml, \"text/html\");\n  const elements = [].concat(...createdDocument.body.querySelectorAll(\"*\"));\n  for (const element2 of elements) {\n    const elementName = element2.nodeName.toLowerCase();\n    if (!Object.keys(allowList).includes(elementName)) {\n      element2.remove();\n      continue;\n    }\n    const attributeList = [].concat(...element2.attributes);\n    const allowedAttributes = [].concat(allowList[\"*\"] || [], allowList[elementName] || []);\n    for (const attribute of attributeList) {\n      if (!allowedAttribute(attribute, allowedAttributes)) {\n        element2.removeAttribute(attribute.nodeName);\n      }\n    }\n  }\n  return createdDocument.body.innerHTML;\n}\nconst NAME$h = \"TemplateFactory\";\nconst Default$8 = {\n  allowList: DefaultAllowlist,\n  content: {},\n  // { selector : text ,  selector2 : text2 , }\n  extraClass: \"\",\n  html: false,\n  sanitize: true,\n  sanitizeFn: null,\n  template: \"<div></div>\"\n};\nconst DefaultType$8 = {\n  allowList: \"object\",\n  content: \"object\",\n  extraClass: \"(string|function)\",\n  html: \"boolean\",\n  sanitize: \"boolean\",\n  sanitizeFn: \"(null|function)\",\n  template: \"string\"\n};\nconst DefaultContentType = {\n  entry: \"(string|element|function|null)\",\n  selector: \"(string|element)\"\n};\nclass TemplateFactory extends Config {\n  constructor(config) {\n    super();\n    this._config = this._getConfig(config);\n  }\n  // Getters\n  static get Default() {\n    return Default$8;\n  }\n  static get DefaultType() {\n    return DefaultType$8;\n  }\n  static get NAME() {\n    return NAME$h;\n  }\n  // Public\n  getContent() {\n    return Object.values(this._config.content).map((config) => this._resolvePossibleFunction(config)).filter(Boolean);\n  }\n  hasContent() {\n    return this.getContent().length > 0;\n  }\n  changeContent(content) {\n    this._checkContent(content);\n    this._config.content = { ...this._config.content, ...content };\n    return this;\n  }\n  toHtml() {\n    const templateWrapper = document.createElement(\"div\");\n    templateWrapper.innerHTML = this._maybeSanitize(this._config.template);\n    for (const [selector, text] of Object.entries(this._config.content)) {\n      this._setContent(templateWrapper, text, selector);\n    }\n    const template = templateWrapper.children[0];\n    const extraClass = this._resolvePossibleFunction(this._config.extraClass);\n    if (extraClass) {\n      template.classList.add(...extraClass.split(\" \"));\n    }\n    return template;\n  }\n  // Private\n  _typeCheckConfig(config) {\n    super._typeCheckConfig(config);\n    this._checkContent(config.content);\n  }\n  _checkContent(arg) {\n    for (const [selector, content] of Object.entries(arg)) {\n      super._typeCheckConfig({ selector, entry: content }, DefaultContentType);\n    }\n  }\n  _setContent(template, content, selector) {\n    const templateElement = SelectorEngine.findOne(selector, template);\n    if (!templateElement) {\n      return;\n    }\n    content = this._resolvePossibleFunction(content);\n    if (!content) {\n      templateElement.remove();\n      return;\n    }\n    if (isElement$1(content)) {\n      this._putElementInTemplate(getElement(content), templateElement);\n      return;\n    }\n    if (this._config.html) {\n      templateElement.innerHTML = this._maybeSanitize(content);\n      return;\n    }\n    templateElement.textContent = content;\n  }\n  _maybeSanitize(arg) {\n    return this._config.sanitize ? sanitizeHtml(arg, this._config.allowList, this._config.sanitizeFn) : arg;\n  }\n  _resolvePossibleFunction(arg) {\n    return execute(arg, [this]);\n  }\n  _putElementInTemplate(element2, templateElement) {\n    if (this._config.html) {\n      templateElement.innerHTML = \"\";\n      templateElement.append(element2);\n      return;\n    }\n    templateElement.textContent = element2.textContent;\n  }\n}\nconst NAME$g = \"tooltip\";\nconst DISALLOWED_ATTRIBUTES = /* @__PURE__ */ new Set([\"sanitize\", \"allowList\", \"sanitizeFn\"]);\nconst CLASS_NAME_FADE$3 = \"fade\";\nconst CLASS_NAME_MODAL = \"modal\";\nconst CLASS_NAME_SHOW$5 = \"show\";\nconst SELECTOR_TOOLTIP_INNER = \".tooltip-inner\";\nconst SELECTOR_MODAL = `.${CLASS_NAME_MODAL}`;\nconst EVENT_MODAL_HIDE = \"hide.bs.modal\";\nconst TRIGGER_HOVER = \"hover\";\nconst TRIGGER_FOCUS = \"focus\";\nconst TRIGGER_CLICK = \"click\";\nconst TRIGGER_MANUAL = \"manual\";\nconst EVENT_HIDE$6 = \"hide\";\nconst EVENT_HIDDEN$6 = \"hidden\";\nconst EVENT_SHOW$6 = \"show\";\nconst EVENT_SHOWN$6 = \"shown\";\nconst EVENT_INSERTED = \"inserted\";\nconst EVENT_CLICK$1 = \"click\";\nconst EVENT_FOCUSIN$1 = \"focusin\";\nconst EVENT_FOCUSOUT$1 = \"focusout\";\nconst EVENT_MOUSEENTER = \"mouseenter\";\nconst EVENT_MOUSELEAVE = \"mouseleave\";\nconst AttachmentMap = {\n  AUTO: \"auto\",\n  TOP: \"top\",\n  RIGHT: isRTL() ? \"left\" : \"right\",\n  BOTTOM: \"bottom\",\n  LEFT: isRTL() ? \"right\" : \"left\"\n};\nconst Default$7 = {\n  allowList: DefaultAllowlist,\n  animation: true,\n  boundary: \"clippingParents\",\n  container: false,\n  customClass: \"\",\n  delay: 0,\n  fallbackPlacements: [\"top\", \"right\", \"bottom\", \"left\"],\n  html: false,\n  offset: [0, 6],\n  placement: \"top\",\n  popperConfig: null,\n  sanitize: true,\n  sanitizeFn: null,\n  selector: false,\n  template: '<div class=\"tooltip\" role=\"tooltip\"><div class=\"tooltip-arrow\"></div><div class=\"tooltip-inner\"></div></div>',\n  title: \"\",\n  trigger: \"hover focus\"\n};\nconst DefaultType$7 = {\n  allowList: \"object\",\n  animation: \"boolean\",\n  boundary: \"(string|element)\",\n  container: \"(string|element|boolean)\",\n  customClass: \"(string|function)\",\n  delay: \"(number|object)\",\n  fallbackPlacements: \"array\",\n  html: \"boolean\",\n  offset: \"(array|string|function)\",\n  placement: \"(string|function)\",\n  popperConfig: \"(null|object|function)\",\n  sanitize: \"boolean\",\n  sanitizeFn: \"(null|function)\",\n  selector: \"(string|boolean)\",\n  template: \"string\",\n  title: \"(string|element|function)\",\n  trigger: \"string\"\n};\nlet Tooltip$1 = class Tooltip extends BaseComponent$1 {\n  constructor(element2, config) {\n    if (typeof Popper === \"undefined\") {\n      throw new TypeError(\"Bootstrap's tooltips require Popper (https://popper.js.org)\");\n    }\n    super(element2, config);\n    this._isEnabled = true;\n    this._timeout = 0;\n    this._isHovered = null;\n    this._activeTrigger = {};\n    this._popper = null;\n    this._templateFactory = null;\n    this._newContent = null;\n    this.tip = null;\n    this._setListeners();\n    if (!this._config.selector) {\n      this._fixTitle();\n    }\n  }\n  // Getters\n  static get Default() {\n    return Default$7;\n  }\n  static get DefaultType() {\n    return DefaultType$7;\n  }\n  static get NAME() {\n    return NAME$g;\n  }\n  // Public\n  enable() {\n    this._isEnabled = true;\n  }\n  disable() {\n    this._isEnabled = false;\n  }\n  toggleEnabled() {\n    this._isEnabled = !this._isEnabled;\n  }\n  toggle() {\n    if (!this._isEnabled) {\n      return;\n    }\n    this._activeTrigger.click = !this._activeTrigger.click;\n    if (this._isShown()) {\n      this._leave();\n      return;\n    }\n    this._enter();\n  }\n  dispose() {\n    clearTimeout(this._timeout);\n    EventHandler.off(\n      this._element.closest(SELECTOR_MODAL),\n      EVENT_MODAL_HIDE,\n      this._hideModalHandler\n    );\n    if (this._element.getAttribute(\"data-mdb-original-title\")) {\n      this._element.setAttribute(\"title\", this._element.getAttribute(\"data-mdb-original-title\"));\n    }\n    this._disposePopper();\n    super.dispose();\n  }\n  show() {\n    if (this._element.style.display === \"none\") {\n      throw new Error(\"Please use show on visible elements\");\n    }\n    if (!(this._isWithContent() && this._isEnabled)) {\n      return;\n    }\n    const showEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOW$6));\n    const shadowRoot = findShadowRoot(this._element);\n    const isInTheDom = (shadowRoot || this._element.ownerDocument.documentElement).contains(\n      this._element\n    );\n    if (showEvent.defaultPrevented || !isInTheDom) {\n      return;\n    }\n    this._disposePopper();\n    const tip = this._getTipElement();\n    this._element.setAttribute(\"aria-describedby\", tip.getAttribute(\"id\"));\n    const { container } = this._config;\n    if (!this._element.ownerDocument.documentElement.contains(this.tip)) {\n      container.append(tip);\n      EventHandler.trigger(this._element, this.constructor.eventName(EVENT_INSERTED));\n    }\n    this._popper = this._createPopper(tip);\n    tip.classList.add(CLASS_NAME_SHOW$5);\n    if (\"ontouchstart\" in document.documentElement) {\n      for (const element2 of [].concat(...document.body.children)) {\n        EventHandler.on(element2, \"mouseover\", noop);\n      }\n    }\n    const complete = () => {\n      EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOWN$6));\n      if (this._isHovered === false) {\n        this._leave();\n      }\n      this._isHovered = false;\n    };\n    this._queueCallback(complete, this.tip, this._isAnimated());\n  }\n  hide() {\n    if (!this._isShown()) {\n      return;\n    }\n    const hideEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDE$6));\n    if (hideEvent.defaultPrevented) {\n      return;\n    }\n    const tip = this._getTipElement();\n    tip.classList.remove(CLASS_NAME_SHOW$5);\n    if (\"ontouchstart\" in document.documentElement) {\n      for (const element2 of [].concat(...document.body.children)) {\n        EventHandler.off(element2, \"mouseover\", noop);\n      }\n    }\n    this._activeTrigger[TRIGGER_CLICK] = false;\n    this._activeTrigger[TRIGGER_FOCUS] = false;\n    this._activeTrigger[TRIGGER_HOVER] = false;\n    this._isHovered = null;\n    const complete = () => {\n      if (this._isWithActiveTrigger()) {\n        return;\n      }\n      if (!this._isHovered) {\n        this._disposePopper();\n      }\n      this._element.removeAttribute(\"aria-describedby\");\n      EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDDEN$6));\n    };\n    this._queueCallback(complete, this.tip, this._isAnimated());\n  }\n  update() {\n    if (this._popper) {\n      this._popper.update();\n    }\n  }\n  // Protected\n  _isWithContent() {\n    return Boolean(this._getTitle());\n  }\n  _getTipElement() {\n    if (!this.tip) {\n      this.tip = this._createTipElement(this._newContent || this._getContentForTemplate());\n    }\n    return this.tip;\n  }\n  _createTipElement(content) {\n    const tip = this._getTemplateFactory(content).toHtml();\n    if (!tip) {\n      return null;\n    }\n    tip.classList.remove(CLASS_NAME_FADE$3, CLASS_NAME_SHOW$5);\n    tip.classList.add(`bs-${this.constructor.NAME}-auto`);\n    const tipId = getUID(this.constructor.NAME).toString();\n    tip.setAttribute(\"id\", tipId);\n    if (this._isAnimated()) {\n      tip.classList.add(CLASS_NAME_FADE$3);\n    }\n    return tip;\n  }\n  setContent(content) {\n    this._newContent = content;\n    if (this._isShown()) {\n      this._disposePopper();\n      this.show();\n    }\n  }\n  _getTemplateFactory(content) {\n    if (this._templateFactory) {\n      this._templateFactory.changeContent(content);\n    } else {\n      this._templateFactory = new TemplateFactory({\n        ...this._config,\n        // the `content` var has to be after `this._config`\n        // to override config.content in case of popover\n        content,\n        extraClass: this._resolvePossibleFunction(this._config.customClass)\n      });\n    }\n    return this._templateFactory;\n  }\n  _getContentForTemplate() {\n    return {\n      [SELECTOR_TOOLTIP_INNER]: this._getTitle()\n    };\n  }\n  _getTitle() {\n    return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute(\"data-mdb-original-title\");\n  }\n  // Private\n  _initializeOnDelegatedTarget(event) {\n    return this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());\n  }\n  _isAnimated() {\n    return this._config.animation || this.tip && this.tip.classList.contains(CLASS_NAME_FADE$3);\n  }\n  _isShown() {\n    return this.tip && this.tip.classList.contains(CLASS_NAME_SHOW$5);\n  }\n  _createPopper(tip) {\n    const placement = execute(this._config.placement, [this, tip, this._element]);\n    const attachment = AttachmentMap[placement.toUpperCase()];\n    return createPopper(this._element, tip, this._getPopperConfig(attachment));\n  }\n  _getOffset() {\n    const { offset: offset2 } = this._config;\n    if (typeof offset2 === \"string\") {\n      return offset2.split(\",\").map((value) => Number.parseInt(value, 10));\n    }\n    if (typeof offset2 === \"function\") {\n      return (popperData) => offset2(popperData, this._element);\n    }\n    return offset2;\n  }\n  _resolvePossibleFunction(arg) {\n    return execute(arg, [this._element]);\n  }\n  _getPopperConfig(attachment) {\n    const defaultBsPopperConfig = {\n      placement: attachment,\n      modifiers: [\n        {\n          name: \"flip\",\n          options: {\n            fallbackPlacements: this._config.fallbackPlacements\n          }\n        },\n        {\n          name: \"offset\",\n          options: {\n            offset: this._getOffset()\n          }\n        },\n        {\n          name: \"preventOverflow\",\n          options: {\n            boundary: this._config.boundary\n          }\n        },\n        {\n          name: \"arrow\",\n          options: {\n            element: `.${this.constructor.NAME}-arrow`\n          }\n        },\n        {\n          name: \"preSetPlacement\",\n          enabled: true,\n          phase: \"beforeMain\",\n          fn: (data) => {\n            this._getTipElement().setAttribute(\"data-popper-placement\", data.state.placement);\n          }\n        }\n      ]\n    };\n    return {\n      ...defaultBsPopperConfig,\n      ...execute(this._config.popperConfig, [defaultBsPopperConfig])\n    };\n  }\n  _setListeners() {\n    const triggers = this._config.trigger.split(\" \");\n    for (const trigger of triggers) {\n      if (trigger === \"click\") {\n        EventHandler.on(\n          this._element,\n          this.constructor.eventName(EVENT_CLICK$1),\n          this._config.selector,\n          (event) => {\n            const context = this._initializeOnDelegatedTarget(event);\n            context.toggle();\n          }\n        );\n      } else if (trigger !== TRIGGER_MANUAL) {\n        const eventIn = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSEENTER) : this.constructor.eventName(EVENT_FOCUSIN$1);\n        const eventOut = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSELEAVE) : this.constructor.eventName(EVENT_FOCUSOUT$1);\n        EventHandler.on(this._element, eventIn, this._config.selector, (event) => {\n          const context = this._initializeOnDelegatedTarget(event);\n          context._activeTrigger[event.type === \"focusin\" ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;\n          context._enter();\n        });\n        EventHandler.on(this._element, eventOut, this._config.selector, (event) => {\n          const context = this._initializeOnDelegatedTarget(event);\n          context._activeTrigger[event.type === \"focusout\" ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);\n          context._leave();\n        });\n      }\n    }\n    this._hideModalHandler = () => {\n      if (this._element) {\n        this.hide();\n      }\n    };\n    EventHandler.on(\n      this._element.closest(SELECTOR_MODAL),\n      EVENT_MODAL_HIDE,\n      this._hideModalHandler\n    );\n  }\n  _fixTitle() {\n    const title = this._element.getAttribute(\"title\");\n    if (!title) {\n      return;\n    }\n    if (!this._element.getAttribute(\"aria-label\") && !this._element.textContent.trim()) {\n      this._element.setAttribute(\"aria-label\", title);\n    }\n    this._element.setAttribute(\"data-mdb-original-title\", title);\n    this._element.removeAttribute(\"title\");\n  }\n  _enter() {\n    if (this._isShown() || this._isHovered) {\n      this._isHovered = true;\n      return;\n    }\n    this._isHovered = true;\n    this._setTimeout(() => {\n      if (this._isHovered) {\n        this.show();\n      }\n    }, this._config.delay.show);\n  }\n  _leave() {\n    if (this._isWithActiveTrigger()) {\n      return;\n    }\n    this._isHovered = false;\n    this._setTimeout(() => {\n      if (!this._isHovered) {\n        this.hide();\n      }\n    }, this._config.delay.hide);\n  }\n  _setTimeout(handler, timeout) {\n    clearTimeout(this._timeout);\n    this._timeout = setTimeout(handler, timeout);\n  }\n  _isWithActiveTrigger() {\n    return Object.values(this._activeTrigger).includes(true);\n  }\n  _getConfig(config) {\n    const dataAttributes = Manipulator.getDataAttributes(this._element);\n    for (const dataAttribute of Object.keys(dataAttributes)) {\n      if (DISALLOWED_ATTRIBUTES.has(dataAttribute)) {\n        delete dataAttributes[dataAttribute];\n      }\n    }\n    config = {\n      ...dataAttributes,\n      ...typeof config === \"object\" && config ? config : {}\n    };\n    config = this._mergeConfigObj(config);\n    config = this._configAfterMerge(config);\n    this._typeCheckConfig(config);\n    return config;\n  }\n  _configAfterMerge(config) {\n    config.container = config.container === false ? document.body : getElement(config.container);\n    if (typeof config.delay === \"number\") {\n      config.delay = {\n        show: config.delay,\n        hide: config.delay\n      };\n    }\n    if (typeof config.title === \"number\") {\n      config.title = config.title.toString();\n    }\n    if (typeof config.content === \"number\") {\n      config.content = config.content.toString();\n    }\n    return config;\n  }\n  _getDelegateConfig() {\n    const config = {};\n    for (const [key, value] of Object.entries(this._config)) {\n      if (this.constructor.Default[key] !== value) {\n        config[key] = value;\n      }\n    }\n    config.selector = false;\n    config.trigger = \"manual\";\n    return config;\n  }\n  _disposePopper() {\n    if (this._popper) {\n      this._popper.destroy();\n      this._popper = null;\n    }\n    if (this.tip) {\n      this.tip.remove();\n      this.tip = null;\n    }\n  }\n  // Static\n  static jQueryInterface(config) {\n    return this.each(function() {\n      const data = Tooltip.getOrCreateInstance(this, config);\n      if (typeof config !== \"string\") {\n        return;\n      }\n      if (typeof data[config] === \"undefined\") {\n        throw new TypeError(`No method named \"${config}\"`);\n      }\n      data[config]();\n    });\n  }\n};\nconst NAME$f = \"popover\";\nconst SELECTOR_TITLE = \".popover-header\";\nconst SELECTOR_CONTENT = \".popover-body\";\nconst Default$6 = {\n  ...Tooltip$1.Default,\n  content: \"\",\n  offset: [0, 8],\n  placement: \"right\",\n  template: '<div class=\"popover\" role=\"tooltip\"><div class=\"popover-arrow\"></div><h3 class=\"popover-header\"></h3><div class=\"popover-body\"></div></div>',\n  trigger: \"click\"\n};\nconst DefaultType$6 = {\n  ...Tooltip$1.DefaultType,\n  content: \"(null|string|element|function)\"\n};\nlet Popover$1 = class Popover extends Tooltip$1 {\n  // Getters\n  static get Default() {\n    return Default$6;\n  }\n  static get DefaultType() {\n    return DefaultType$6;\n  }\n  static get NAME() {\n    return NAME$f;\n  }\n  // Overrides\n  _isWithContent() {\n    return this._getTitle() || this._getContent();\n  }\n  // Private\n  _getContentForTemplate() {\n    return {\n      [SELECTOR_TITLE]: this._getTitle(),\n      [SELECTOR_CONTENT]: this._getContent()\n    };\n  }\n  _getContent() {\n    return this._resolvePossibleFunction(this._config.content);\n  }\n  // Static\n  static jQueryInterface(config) {\n    return this.each(function() {\n      const data = Popover.getOrCreateInstance(this, config);\n      if (typeof config !== \"string\") {\n        return;\n      }\n      if (typeof data[config] === \"undefined\") {\n        throw new TypeError(`No method named \"${config}\"`);\n      }\n      data[config]();\n    });\n  }\n};\nconst NAME$e = \"popover\";\nconst EVENT_SHOW_BS$4 = \"show.bs.popover\";\nconst EVENT_SHOWN_BS$4 = \"shown.bs.popover\";\nconst EVENT_HIDE_BS$4 = \"hide.bs.popover\";\nconst EVENT_HIDDEN_BS$4 = \"hidden.bs.popover\";\nconst EVENT_INSERTED_BS$1 = \"inserted.bs.popover\";\nconst EXTENDED_EVENTS$3 = [\n  { name: \"show\" },\n  { name: \"shown\" },\n  { name: \"hide\" },\n  { name: \"hidden\" },\n  { name: \"inserted\" }\n];\nclass Popover2 extends Popover$1 {\n  constructor(element2, data) {\n    super(element2, data);\n    this._init();\n    Manipulator$1.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, true);\n    bindCallbackEventsIfNeeded(this.constructor);\n  }\n  dispose() {\n    EventHandler$1.off(this.element, EVENT_SHOW_BS$4);\n    EventHandler$1.off(this.element, EVENT_SHOWN_BS$4);\n    EventHandler$1.off(this.element, EVENT_HIDE_BS$4);\n    EventHandler$1.off(this.element, EVENT_HIDDEN_BS$4);\n    EventHandler$1.off(this.element, EVENT_INSERTED_BS$1);\n    Manipulator$1.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`);\n    super.dispose();\n  }\n  // Getters\n  static get NAME() {\n    return NAME$e;\n  }\n  // Private\n  _init() {\n    this._bindMdbEvents();\n  }\n  _bindMdbEvents() {\n    EventHandler$1.extend(this._element, EXTENDED_EVENTS$3, NAME$e);\n  }\n}\nconst NAME$d = \"scrollspy\";\nconst DATA_KEY$a = \"bs.scrollspy\";\nconst EVENT_KEY$7 = `.${DATA_KEY$a}`;\nconst EVENT_ACTIVATE$1 = `activate${EVENT_KEY$7}`;\nconst EVENT_CLICK = `click${EVENT_KEY$7}`;\nconst CLASS_NAME_DROPDOWN_ITEM = \"dropdown-item\";\nconst CLASS_NAME_ACTIVE$2 = \"active\";\nconst SELECTOR_TARGET_LINKS = \"[href]\";\nconst SELECTOR_NAV_LIST_GROUP = \".nav, .list-group\";\nconst SELECTOR_NAV_LINKS = \".nav-link\";\nconst SELECTOR_NAV_ITEMS = \".nav-item\";\nconst SELECTOR_LIST_ITEMS = \".list-group-item\";\nconst SELECTOR_LINK_ITEMS = `${SELECTOR_NAV_LINKS}, ${SELECTOR_NAV_ITEMS} > ${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`;\nconst SELECTOR_DROPDOWN = \".dropdown\";\nconst SELECTOR_DROPDOWN_TOGGLE$1 = \".dropdown-toggle\";\nconst Default$5 = {\n  offset: null,\n  // TODO: v6 @deprecated, keep it for backwards compatibility reasons\n  rootMargin: \"0px 0px -25%\",\n  smoothScroll: false,\n  target: null,\n  threshold: [0.1, 0.5, 1]\n};\nconst DefaultType$5 = {\n  offset: \"(number|null)\",\n  // TODO v6 @deprecated, keep it for backwards compatibility reasons\n  rootMargin: \"string\",\n  smoothScroll: \"boolean\",\n  target: \"element\",\n  threshold: \"array\"\n};\nlet ScrollSpy$1 = class ScrollSpy extends BaseComponent$1 {\n  constructor(element2, config) {\n    super(element2, config);\n    if (!this._config.target) {\n      return;\n    }\n    this._targetLinks = /* @__PURE__ */ new Map();\n    this._observableSections = /* @__PURE__ */ new Map();\n    this._rootElement = getComputedStyle(this._element).overflowY === \"visible\" ? null : this._element;\n    this._activeTarget = null;\n    this._observer = null;\n    this._previousScrollData = {\n      visibleEntryTop: 0,\n      parentScrollTop: 0\n    };\n    this.refresh();\n  }\n  // Getters\n  static get Default() {\n    return Default$5;\n  }\n  static get DefaultType() {\n    return DefaultType$5;\n  }\n  static get NAME() {\n    return NAME$d;\n  }\n  // Public\n  refresh() {\n    this._initializeTargetsAndObservables();\n    this._maybeEnableSmoothScroll();\n    if (this._observer) {\n      this._observer.disconnect();\n    } else {\n      this._observer = this._getNewObserver();\n    }\n    for (const section of this._observableSections.values()) {\n      this._observer.observe(section);\n    }\n  }\n  dispose() {\n    if (this._observer) {\n      this._observer.disconnect();\n    }\n    super.dispose();\n  }\n  // Private\n  _configAfterMerge(config) {\n    config.target = getElement(config.target) || document.body;\n    config.rootMargin = config.offset ? `${config.offset}px 0px -30%` : config.rootMargin;\n    if (typeof config.threshold === \"string\") {\n      config.threshold = config.threshold.split(\",\").map((value) => Number.parseFloat(value));\n    }\n    return config;\n  }\n  _maybeEnableSmoothScroll() {\n    if (!this._config.smoothScroll) {\n      return;\n    }\n    EventHandler.off(this._config.target, EVENT_CLICK);\n    EventHandler.on(this._config.target, EVENT_CLICK, SELECTOR_TARGET_LINKS, (event) => {\n      const observableSection = this._observableSections.get(event.target.hash);\n      if (observableSection) {\n        event.preventDefault();\n        const root = this._rootElement || window;\n        const height = observableSection.offsetTop - this._element.offsetTop;\n        if (root.scrollTo) {\n          root.scrollTo({ top: height, behavior: \"smooth\" });\n          return;\n        }\n        root.scrollTop = height;\n      }\n    });\n  }\n  _getNewObserver() {\n    const options = {\n      root: this._rootElement,\n      threshold: this._config.threshold,\n      rootMargin: this._config.rootMargin\n    };\n    return new IntersectionObserver((entries) => this._observerCallback(entries), options);\n  }\n  // The logic of selection\n  _observerCallback(entries) {\n    const targetElement = (entry) => this._targetLinks.get(`#${entry.target.id}`);\n    const activate = (entry) => {\n      this._previousScrollData.visibleEntryTop = entry.target.offsetTop;\n      this._process(targetElement(entry));\n    };\n    const parentScrollTop = (this._rootElement || document.documentElement).scrollTop;\n    const userScrollsDown = parentScrollTop >= this._previousScrollData.parentScrollTop;\n    this._previousScrollData.parentScrollTop = parentScrollTop;\n    for (const entry of entries) {\n      if (!entry.isIntersecting) {\n        this._activeTarget = null;\n        this._clearActiveClass(targetElement(entry));\n        continue;\n      }\n      const entryIsLowerThanPrevious = entry.target.offsetTop >= this._previousScrollData.visibleEntryTop;\n      if (userScrollsDown && entryIsLowerThanPrevious) {\n        activate(entry);\n        if (!parentScrollTop) {\n          return;\n        }\n        continue;\n      }\n      if (!userScrollsDown && !entryIsLowerThanPrevious) {\n        activate(entry);\n      }\n    }\n  }\n  _initializeTargetsAndObservables() {\n    this._targetLinks = /* @__PURE__ */ new Map();\n    this._observableSections = /* @__PURE__ */ new Map();\n    const targetLinks = SelectorEngine.find(SELECTOR_TARGET_LINKS, this._config.target);\n    for (const anchor of targetLinks) {\n      if (!anchor.hash || isDisabled(anchor)) {\n        continue;\n      }\n      const observableSection = SelectorEngine.findOne(decodeURI(anchor.hash), this._element);\n      if (isVisible(observableSection)) {\n        this._targetLinks.set(decodeURI(anchor.hash), anchor);\n        this._observableSections.set(anchor.hash, observableSection);\n      }\n    }\n  }\n  _process(target) {\n    if (this._activeTarget === target) {\n      return;\n    }\n    this._clearActiveClass(this._config.target);\n    this._activeTarget = target;\n    target.classList.add(CLASS_NAME_ACTIVE$2);\n    this._activateParents(target);\n    EventHandler.trigger(this._element, EVENT_ACTIVATE$1, { relatedTarget: target });\n  }\n  _activateParents(target) {\n    if (target.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {\n      SelectorEngine.findOne(\n        SELECTOR_DROPDOWN_TOGGLE$1,\n        target.closest(SELECTOR_DROPDOWN)\n      ).classList.add(CLASS_NAME_ACTIVE$2);\n      return;\n    }\n    for (const listGroup of SelectorEngine.parents(target, SELECTOR_NAV_LIST_GROUP)) {\n      for (const item of SelectorEngine.prev(listGroup, SELECTOR_LINK_ITEMS)) {\n        item.classList.add(CLASS_NAME_ACTIVE$2);\n      }\n    }\n  }\n  _clearActiveClass(parent) {\n    parent.classList.remove(CLASS_NAME_ACTIVE$2);\n    const activeNodes = SelectorEngine.find(\n      `${SELECTOR_TARGET_LINKS}.${CLASS_NAME_ACTIVE$2}`,\n      parent\n    );\n    for (const node of activeNodes) {\n      node.classList.remove(CLASS_NAME_ACTIVE$2);\n    }\n  }\n  // Static\n  static jQueryInterface(config) {\n    return this.each(function() {\n      const data = ScrollSpy.getOrCreateInstance(this, config);\n      if (typeof config !== \"string\") {\n        return;\n      }\n      if (data[config] === void 0 || config.startsWith(\"_\") || config === \"constructor\") {\n        throw new TypeError(`No method named \"${config}\"`);\n      }\n      data[config]();\n    });\n  }\n};\nconst NAME$c = \"scrollspy\";\nconst DATA_KEY$9 = `mdb.${NAME$c}`;\nconst EVENT_KEY$6 = `.${DATA_KEY$9}`;\nconst EVENT_ACTIVATE_BS = \"activate.bs.scrollspy\";\nconst EVENT_ACTIVATE = `activate${EVENT_KEY$6}`;\nconst CLASS_COLLAPSIBLE = \"collapsible-scrollspy\";\nconst CLASS_ACTIVE = \"active\";\nconst SELECTOR_LIST = \"ul\";\nconst SELECTOR_ACTIVE = `.${CLASS_ACTIVE}`;\nconst SELECTOR_COLLAPSIBLE_SCROLLSPY = `.${CLASS_COLLAPSIBLE}`;\nclass ScrollSpy2 extends ScrollSpy$1 {\n  constructor(element2, data) {\n    super(element2, data);\n    this._collapsibles = [];\n    this._init();\n    Manipulator$1.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, true);\n    bindCallbackEventsIfNeeded(this.constructor);\n  }\n  dispose() {\n    EventHandler$1.off(this._scrollElement, EVENT_ACTIVATE_BS);\n    Manipulator$1.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`);\n    super.dispose();\n  }\n  // Getters\n  static get NAME() {\n    return NAME$c;\n  }\n  // Private\n  _init() {\n    this._bindActivateEvent();\n    this._getCollapsibles();\n    if (this._collapsibles.length === 0) {\n      return;\n    }\n    this._showSubsection();\n    this._hideSubsection();\n  }\n  _getHeight(element2) {\n    return element2.offsetHeight;\n  }\n  _hide(target) {\n    const itemsToHide = SelectorEngine$1.findOne(SELECTOR_LIST, target.parentNode);\n    itemsToHide.style.overflow = \"hidden\";\n    itemsToHide.style.height = `${0}px`;\n  }\n  _show(target, destinedHeight) {\n    target.style.height = destinedHeight;\n  }\n  _getCollapsibles() {\n    const collapsibleElements = SelectorEngine$1.find(SELECTOR_COLLAPSIBLE_SCROLLSPY);\n    if (!collapsibleElements) {\n      return;\n    }\n    collapsibleElements.forEach((collapsibleElement) => {\n      const listParent = collapsibleElement.parentNode;\n      const list = SelectorEngine$1.findOne(SELECTOR_LIST, listParent);\n      const listHeight = list.offsetHeight;\n      this._collapsibles.push({\n        element: list,\n        relatedTarget: collapsibleElement.getAttribute(\"href\"),\n        height: `${listHeight}px`\n      });\n    });\n  }\n  _showSubsection() {\n    const activeElements = SelectorEngine$1.find(SELECTOR_ACTIVE);\n    const actives = activeElements.filter((active) => {\n      return Manipulator$1.hasClass(active, CLASS_COLLAPSIBLE);\n    });\n    actives.forEach((active) => {\n      const list = SelectorEngine$1.findOne(SELECTOR_LIST, active.parentNode);\n      const height = this._collapsibles.find((collapsible) => {\n        return collapsible.relatedTarget = active.getAttribute(\"href\");\n      }).height;\n      this._show(list, height);\n    });\n  }\n  _hideSubsection() {\n    const unactives = SelectorEngine$1.find(SELECTOR_COLLAPSIBLE_SCROLLSPY).filter((collapsible) => {\n      return Manipulator$1.hasClass(collapsible, \"active\") === false;\n    });\n    unactives.forEach((unactive) => {\n      this._hide(unactive);\n    });\n  }\n  _bindActivateEvent() {\n    EventHandler$1.on(this._element, EVENT_ACTIVATE_BS, (e) => {\n      this._showSubsection();\n      this._hideSubsection();\n      EventHandler$1.trigger(this._element, EVENT_ACTIVATE, {\n        relatedTarget: e.relatedTarget\n      });\n    });\n  }\n}\nconst NAME$b = \"tab\";\nconst DATA_KEY$8 = \"bs.tab\";\nconst EVENT_KEY$5 = `.${DATA_KEY$8}`;\nconst EVENT_HIDE$5 = `hide${EVENT_KEY$5}`;\nconst EVENT_HIDDEN$5 = `hidden${EVENT_KEY$5}`;\nconst EVENT_SHOW$5 = `show${EVENT_KEY$5}`;\nconst EVENT_SHOWN$5 = `shown${EVENT_KEY$5}`;\nconst EVENT_KEYDOWN = `keydown${EVENT_KEY$5}`;\nconst ARROW_LEFT_KEY = \"ArrowLeft\";\nconst ARROW_RIGHT_KEY = \"ArrowRight\";\nconst ARROW_UP_KEY$1 = \"ArrowUp\";\nconst ARROW_DOWN_KEY$1 = \"ArrowDown\";\nconst HOME_KEY = \"Home\";\nconst END_KEY = \"End\";\nconst CLASS_NAME_ACTIVE$1 = \"active\";\nconst CLASS_NAME_FADE$2 = \"fade\";\nconst CLASS_NAME_SHOW$4 = \"show\";\nconst CLASS_DROPDOWN = \"dropdown\";\nconst SELECTOR_DROPDOWN_TOGGLE = \".dropdown-toggle\";\nconst SELECTOR_DROPDOWN_MENU = \".dropdown-menu\";\nconst NOT_SELECTOR_DROPDOWN_TOGGLE = `:not(${SELECTOR_DROPDOWN_TOGGLE})`;\nconst SELECTOR_TAB_PANEL = '.list-group, .nav, [role=\"tablist\"]';\nconst SELECTOR_OUTER = \".nav-item, .list-group-item\";\nconst SELECTOR_INNER = `.nav-link${NOT_SELECTOR_DROPDOWN_TOGGLE}, .list-group-item${NOT_SELECTOR_DROPDOWN_TOGGLE}, [role=\"tab\"]${NOT_SELECTOR_DROPDOWN_TOGGLE}`;\nconst SELECTOR_DATA_TOGGLE$2 = \"[data-mdb-tab-initialized]\";\nconst SELECTOR_INNER_ELEM = `${SELECTOR_INNER}, ${SELECTOR_DATA_TOGGLE$2}`;\nlet Tab$1 = class Tab extends BaseComponent$1 {\n  constructor(element2) {\n    super(element2);\n    this._parent = this._element.closest(SELECTOR_TAB_PANEL);\n    if (!this._parent) {\n      return;\n    }\n    this._setInitialAttributes(this._parent, this._getChildren());\n    EventHandler.on(this._element, EVENT_KEYDOWN, (event) => this._keydown(event));\n  }\n  // Getters\n  static get NAME() {\n    return NAME$b;\n  }\n  // Public\n  show() {\n    const innerElem = this._element;\n    if (this._elemIsActive(innerElem)) {\n      return;\n    }\n    const active = this._getActiveElem();\n    const hideEvent = active ? EventHandler.trigger(active, EVENT_HIDE$5, { relatedTarget: innerElem }) : null;\n    const showEvent = EventHandler.trigger(innerElem, EVENT_SHOW$5, { relatedTarget: active });\n    if (showEvent.defaultPrevented || hideEvent && hideEvent.defaultPrevented) {\n      return;\n    }\n    this._deactivate(active, innerElem);\n    this._activate(innerElem, active);\n  }\n  // Private\n  _activate(element2, relatedElem) {\n    if (!element2) {\n      return;\n    }\n    element2.classList.add(CLASS_NAME_ACTIVE$1);\n    this._activate(SelectorEngine.getElementFromSelector(element2));\n    const complete = () => {\n      if (element2.getAttribute(\"role\") !== \"tab\") {\n        element2.classList.add(CLASS_NAME_SHOW$4);\n        return;\n      }\n      element2.removeAttribute(\"tabindex\");\n      element2.setAttribute(\"aria-selected\", true);\n      this._toggleDropDown(element2, true);\n      EventHandler.trigger(element2, EVENT_SHOWN$5, {\n        relatedTarget: relatedElem\n      });\n    };\n    this._queueCallback(complete, element2, element2.classList.contains(CLASS_NAME_FADE$2));\n  }\n  _deactivate(element2, relatedElem) {\n    if (!element2) {\n      return;\n    }\n    element2.classList.remove(CLASS_NAME_ACTIVE$1);\n    element2.blur();\n    this._deactivate(SelectorEngine.getElementFromSelector(element2));\n    const complete = () => {\n      if (element2.getAttribute(\"role\") !== \"tab\") {\n        element2.classList.remove(CLASS_NAME_SHOW$4);\n        return;\n      }\n      element2.setAttribute(\"aria-selected\", false);\n      element2.setAttribute(\"tabindex\", \"-1\");\n      this._toggleDropDown(element2, false);\n      EventHandler.trigger(element2, EVENT_HIDDEN$5, { relatedTarget: relatedElem });\n    };\n    this._queueCallback(complete, element2, element2.classList.contains(CLASS_NAME_FADE$2));\n  }\n  _keydown(event) {\n    if (![ARROW_LEFT_KEY, ARROW_RIGHT_KEY, ARROW_UP_KEY$1, ARROW_DOWN_KEY$1, HOME_KEY, END_KEY].includes(\n      event.key\n    )) {\n      return;\n    }\n    event.stopPropagation();\n    event.preventDefault();\n    const children = this._getChildren().filter((element2) => !isDisabled(element2));\n    let nextActiveElement;\n    if ([HOME_KEY, END_KEY].includes(event.key)) {\n      nextActiveElement = children[event.key === HOME_KEY ? 0 : children.length - 1];\n    } else {\n      const isNext = [ARROW_RIGHT_KEY, ARROW_DOWN_KEY$1].includes(event.key);\n      nextActiveElement = getNextActiveElement(children, event.target, isNext, true);\n    }\n    if (nextActiveElement) {\n      nextActiveElement.focus({ preventScroll: true });\n      Tab.getOrCreateInstance(nextActiveElement).show();\n    }\n  }\n  _getChildren() {\n    return SelectorEngine.find(SELECTOR_INNER_ELEM, this._parent);\n  }\n  _getActiveElem() {\n    return this._getChildren().find((child) => this._elemIsActive(child)) || null;\n  }\n  _setInitialAttributes(parent, children) {\n    this._setAttributeIfNotExists(parent, \"role\", \"tablist\");\n    for (const child of children) {\n      this._setInitialAttributesOnChild(child);\n    }\n  }\n  _setInitialAttributesOnChild(child) {\n    child = this._getInnerElement(child);\n    const isActive = this._elemIsActive(child);\n    const outerElem = this._getOuterElement(child);\n    child.setAttribute(\"aria-selected\", isActive);\n    if (outerElem !== child) {\n      this._setAttributeIfNotExists(outerElem, \"role\", \"presentation\");\n    }\n    if (!isActive) {\n      child.setAttribute(\"tabindex\", \"-1\");\n    }\n    this._setAttributeIfNotExists(child, \"role\", \"tab\");\n    this._setInitialAttributesOnTargetPanel(child);\n  }\n  _setInitialAttributesOnTargetPanel(child) {\n    const target = SelectorEngine.getElementFromSelector(child);\n    if (!target) {\n      return;\n    }\n    this._setAttributeIfNotExists(target, \"role\", \"tabpanel\");\n    if (child.id) {\n      this._setAttributeIfNotExists(target, \"aria-labelledby\", `${child.id}`);\n    }\n  }\n  _toggleDropDown(element2, open) {\n    const outerElem = this._getOuterElement(element2);\n    if (!outerElem.classList.contains(CLASS_DROPDOWN)) {\n      return;\n    }\n    const toggle = (selector, className) => {\n      const element3 = SelectorEngine.findOne(selector, outerElem);\n      if (element3) {\n        element3.classList.toggle(className, open);\n      }\n    };\n    toggle(SELECTOR_DROPDOWN_TOGGLE, CLASS_NAME_ACTIVE$1);\n    toggle(SELECTOR_DROPDOWN_MENU, CLASS_NAME_SHOW$4);\n    outerElem.setAttribute(\"aria-expanded\", open);\n  }\n  _setAttributeIfNotExists(element2, attribute, value) {\n    if (!element2.hasAttribute(attribute)) {\n      element2.setAttribute(attribute, value);\n    }\n  }\n  _elemIsActive(elem) {\n    return elem.classList.contains(CLASS_NAME_ACTIVE$1);\n  }\n  // Try to get the inner element (usually the .nav-link)\n  _getInnerElement(elem) {\n    return elem.matches(SELECTOR_INNER_ELEM) ? elem : SelectorEngine.findOne(SELECTOR_INNER_ELEM, elem);\n  }\n  // Try to get the outer element (usually the .nav-item)\n  _getOuterElement(elem) {\n    return elem.closest(SELECTOR_OUTER) || elem;\n  }\n  // Static\n  static jQueryInterface(config) {\n    return this.each(function() {\n      const data = Tab.getOrCreateInstance(this);\n      if (typeof config !== \"string\") {\n        return;\n      }\n      if (data[config] === void 0 || config.startsWith(\"_\") || config === \"constructor\") {\n        throw new TypeError(`No method named \"${config}\"`);\n      }\n      data[config]();\n    });\n  }\n};\nconst NAME$a = \"tab\";\nconst DATA_KEY$7 = `mdb.${NAME$a}`;\nconst EVENT_KEY$4 = `.${DATA_KEY$7}`;\nconst EVENT_SHOW_BS$3 = \"show.bs.tab\";\nconst EVENT_SHOWN_BS$3 = \"shown.bs.tab\";\nconst EVENT_HIDE_BS$3 = \"hide.bs.tab\";\nconst EVENT_HIDDEN_BS$3 = \"hidden.bs.tab\";\nconst EVENT_SHOW$4 = `show${EVENT_KEY$4}`;\nconst EVENT_SHOWN$4 = `shown${EVENT_KEY$4}`;\nconst EVENT_HIDE$4 = `hide${EVENT_KEY$4}`;\nconst EVENT_HIDDEN$4 = `hidden${EVENT_KEY$4}`;\nconst CLASS_NAME_ACTIVE = \"active\";\nconst CLASS_NAME_FADE$1 = \"fade\";\nconst CLASS_NAME_SHOW$3 = \"show\";\nclass Tab2 extends Tab$1 {\n  constructor(element2) {\n    super(element2);\n    Manipulator$1.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, true);\n    bindCallbackEventsIfNeeded(this.constructor);\n  }\n  dispose() {\n    EventHandler$1.off(this._element, EVENT_SHOW_BS$3);\n    EventHandler$1.off(this._element, EVENT_SHOWN_BS$3);\n    Manipulator$1.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`);\n    super.dispose();\n  }\n  // Getters\n  static get NAME() {\n    return NAME$a;\n  }\n  // Override\n  show() {\n    const innerElem = this._element;\n    if (this._elemIsActive(innerElem)) {\n      return;\n    }\n    const active = this._getActiveElem();\n    let hideEvent = null;\n    let hideEventMdb = null;\n    if (active) {\n      hideEvent = EventHandler$1.trigger(active, EVENT_HIDE_BS$3, { relatedTarget: innerElem });\n      hideEventMdb = EventHandler$1.trigger(active, EVENT_HIDE$4, { relatedTarget: innerElem });\n    }\n    const showEvent = EventHandler$1.trigger(innerElem, EVENT_SHOW_BS$3, { relatedTarget: active });\n    const showEventMdb = EventHandler$1.trigger(innerElem, EVENT_SHOW$4, { relatedTarget: active });\n    if (showEvent.defaultPrevented || showEventMdb.defaultPrevented || hideEvent && hideEvent.defaultPrevented || hideEventMdb && hideEventMdb.defaultPrevented) {\n      return;\n    }\n    this._deactivate(active, innerElem);\n    this._activate(innerElem, active);\n  }\n  _activate(element2, relatedElem) {\n    if (!element2) {\n      return;\n    }\n    element2.classList.add(CLASS_NAME_ACTIVE);\n    this._activate(getElementFromSelector(element2));\n    const complete = () => {\n      if (element2.getAttribute(\"role\") !== \"tab\") {\n        element2.classList.add(CLASS_NAME_SHOW$3);\n        return;\n      }\n      element2.focus();\n      element2.removeAttribute(\"tabindex\");\n      element2.setAttribute(\"aria-selected\", true);\n      this._toggleDropDown(element2, true);\n      EventHandler$1.trigger(element2, EVENT_SHOWN_BS$3, {\n        relatedTarget: relatedElem\n      });\n      EventHandler$1.trigger(element2, EVENT_SHOWN$4, {\n        relatedTarget: relatedElem\n      });\n    };\n    this._queueCallback(complete, element2, element2.classList.contains(CLASS_NAME_FADE$1));\n  }\n  _deactivate(element2, relatedElem) {\n    if (!element2) {\n      return;\n    }\n    element2.classList.remove(CLASS_NAME_ACTIVE);\n    element2.blur();\n    this._deactivate(getElementFromSelector(element2));\n    const complete = () => {\n      if (element2.getAttribute(\"role\") !== \"tab\") {\n        element2.classList.remove(CLASS_NAME_SHOW$3);\n        return;\n      }\n      element2.setAttribute(\"aria-selected\", false);\n      element2.setAttribute(\"tabindex\", \"-1\");\n      this._toggleDropDown(element2, false);\n      EventHandler$1.trigger(element2, EVENT_HIDDEN_BS$3, { relatedTarget: relatedElem });\n      EventHandler$1.trigger(element2, EVENT_HIDDEN$4, { relatedTarget: relatedElem });\n    };\n    this._queueCallback(complete, element2, element2.classList.contains(CLASS_NAME_FADE$1));\n  }\n}\nconst NAME$9 = \"tooltip\";\nconst EVENT_HIDE_BS$2 = \"hide.bs.tooltip\";\nconst EVENT_HIDDEN_BS$2 = \"hidden.bs.tooltip\";\nconst EVENT_SHOW_BS$2 = \"show.bs.tooltip\";\nconst EVENT_SHOWN_BS$2 = \"shown.bs.tooltip\";\nconst EVENT_INSERTED_BS = \"inserted.bs.tooltip\";\nconst EXTENDED_EVENTS$2 = [\n  { name: \"show\" },\n  { name: \"shown\" },\n  { name: \"hide\" },\n  { name: \"hidden\" },\n  { name: \"inserted\" }\n];\nclass Tooltip2 extends Tooltip$1 {\n  constructor(element2, data) {\n    super(element2, data);\n    this._init();\n    Manipulator$1.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, true);\n    bindCallbackEventsIfNeeded(this.constructor);\n  }\n  dispose() {\n    EventHandler$1.off(this._element, EVENT_SHOW_BS$2);\n    EventHandler$1.off(this._element, EVENT_SHOWN_BS$2);\n    EventHandler$1.off(this._element, EVENT_HIDE_BS$2);\n    EventHandler$1.off(this._element, EVENT_HIDDEN_BS$2);\n    EventHandler$1.off(this._element, EVENT_INSERTED_BS);\n    Manipulator$1.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`);\n    super.dispose();\n  }\n  // Getters\n  static get NAME() {\n    return NAME$9;\n  }\n  // Private\n  _init() {\n    this._bindMdbEvents();\n  }\n  _bindMdbEvents() {\n    EventHandler$1.extend(this._element, EXTENDED_EVENTS$2, NAME$9);\n  }\n}\nconst NAME$8 = \"toast\";\nconst DATA_KEY$6 = \"bs.toast\";\nconst EVENT_KEY$3 = `.${DATA_KEY$6}`;\nconst EVENT_MOUSEOVER = `mouseover${EVENT_KEY$3}`;\nconst EVENT_MOUSEOUT = `mouseout${EVENT_KEY$3}`;\nconst EVENT_FOCUSIN = `focusin${EVENT_KEY$3}`;\nconst EVENT_FOCUSOUT = `focusout${EVENT_KEY$3}`;\nconst EVENT_HIDE$3 = `hide${EVENT_KEY$3}`;\nconst EVENT_HIDDEN$3 = `hidden${EVENT_KEY$3}`;\nconst EVENT_SHOW$3 = `show${EVENT_KEY$3}`;\nconst EVENT_SHOWN$3 = `shown${EVENT_KEY$3}`;\nconst CLASS_NAME_FADE = \"fade\";\nconst CLASS_NAME_HIDE = \"hide\";\nconst CLASS_NAME_SHOW$2 = \"show\";\nconst CLASS_NAME_SHOWING = \"showing\";\nconst DefaultType$4 = {\n  animation: \"boolean\",\n  autohide: \"boolean\",\n  delay: \"number\"\n};\nconst Default$4 = {\n  animation: true,\n  autohide: true,\n  delay: 5e3\n};\nlet Toast$1 = class Toast extends BaseComponent$1 {\n  constructor(element2, config) {\n    super(element2, config);\n    this._timeout = null;\n    this._hasMouseInteraction = false;\n    this._hasKeyboardInteraction = false;\n    this._setListeners();\n  }\n  // Getters\n  static get Default() {\n    return Default$4;\n  }\n  static get DefaultType() {\n    return DefaultType$4;\n  }\n  static get NAME() {\n    return NAME$8;\n  }\n  // Public\n  show() {\n    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3);\n    if (showEvent.defaultPrevented) {\n      return;\n    }\n    this._clearTimeout();\n    if (this._config.animation) {\n      this._element.classList.add(CLASS_NAME_FADE);\n    }\n    const complete = () => {\n      this._element.classList.remove(CLASS_NAME_SHOWING);\n      EventHandler.trigger(this._element, EVENT_SHOWN$3);\n      this._maybeScheduleHide();\n    };\n    this._element.classList.remove(CLASS_NAME_HIDE);\n    reflow(this._element);\n    this._element.classList.add(CLASS_NAME_SHOW$2, CLASS_NAME_SHOWING);\n    this._queueCallback(complete, this._element, this._config.animation);\n  }\n  hide() {\n    if (!this.isShown()) {\n      return;\n    }\n    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);\n    if (hideEvent.defaultPrevented) {\n      return;\n    }\n    const complete = () => {\n      this._element.classList.add(CLASS_NAME_HIDE);\n      this._element.classList.remove(CLASS_NAME_SHOWING, CLASS_NAME_SHOW$2);\n      EventHandler.trigger(this._element, EVENT_HIDDEN$3);\n    };\n    this._element.classList.add(CLASS_NAME_SHOWING);\n    this._queueCallback(complete, this._element, this._config.animation);\n  }\n  dispose() {\n    this._clearTimeout();\n    if (this.isShown()) {\n      this._element.classList.remove(CLASS_NAME_SHOW$2);\n    }\n    super.dispose();\n  }\n  isShown() {\n    return this._element.classList.contains(CLASS_NAME_SHOW$2);\n  }\n  // Private\n  _maybeScheduleHide() {\n    if (!this._config.autohide) {\n      return;\n    }\n    if (this._hasMouseInteraction || this._hasKeyboardInteraction) {\n      return;\n    }\n    this._timeout = setTimeout(() => {\n      this.hide();\n    }, this._config.delay);\n  }\n  _onInteraction(event, isInteracting) {\n    switch (event.type) {\n      case \"mouseover\":\n      case \"mouseout\": {\n        this._hasMouseInteraction = isInteracting;\n        break;\n      }\n      case \"focusin\":\n      case \"focusout\": {\n        this._hasKeyboardInteraction = isInteracting;\n        break;\n      }\n    }\n    if (isInteracting) {\n      this._clearTimeout();\n      return;\n    }\n    const nextElement = event.relatedTarget;\n    if (this._element === nextElement || this._element.contains(nextElement)) {\n      return;\n    }\n    this._maybeScheduleHide();\n  }\n  _setListeners() {\n    EventHandler.on(this._element, EVENT_MOUSEOVER, (event) => this._onInteraction(event, true));\n    EventHandler.on(this._element, EVENT_MOUSEOUT, (event) => this._onInteraction(event, false));\n    EventHandler.on(this._element, EVENT_FOCUSIN, (event) => this._onInteraction(event, true));\n    EventHandler.on(this._element, EVENT_FOCUSOUT, (event) => this._onInteraction(event, false));\n  }\n  _clearTimeout() {\n    clearTimeout(this._timeout);\n    this._timeout = null;\n  }\n  // Static\n  static jQueryInterface(config) {\n    return this.each(function() {\n      const data = Toast.getOrCreateInstance(this, config);\n      if (typeof config === \"string\") {\n        if (typeof data[config] === \"undefined\") {\n          throw new TypeError(`No method named \"${config}\"`);\n        }\n        data[config](this);\n      }\n    });\n  }\n};\nconst NAME$7 = \"toast\";\nconst EVENT_SHOW_BS$1 = \"show.bs.toast\";\nconst EVENT_SHOWN_BS$1 = \"shown.bs.toast\";\nconst EVENT_HIDE_BS$1 = \"hide.bs.toast\";\nconst EVENT_HIDDEN_BS$1 = \"hidden.bs.toast\";\nconst EXTENDED_EVENTS$1 = [{ name: \"show\" }, { name: \"shown\" }, { name: \"hide\" }, { name: \"hidden\" }];\nclass Toast2 extends Toast$1 {\n  constructor(element2, data) {\n    super(element2, data);\n    this._init();\n    Manipulator$1.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, true);\n    bindCallbackEventsIfNeeded(this.constructor);\n  }\n  dispose() {\n    EventHandler$1.off(this._element, EVENT_SHOW_BS$1);\n    EventHandler$1.off(this._element, EVENT_SHOWN_BS$1);\n    EventHandler$1.off(this._element, EVENT_HIDE_BS$1);\n    EventHandler$1.off(this._element, EVENT_HIDDEN_BS$1);\n    Manipulator$1.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`);\n    super.dispose();\n  }\n  // Getters\n  static get NAME() {\n    return NAME$7;\n  }\n  // Private\n  _init() {\n    this._bindMdbEvents();\n  }\n  _bindMdbEvents() {\n    EventHandler$1.extend(this._element, EXTENDED_EVENTS$1, NAME$7);\n  }\n}\n(() => {\n  var e = { 454: (e2, t2, n2) => {\n    n2.d(t2, { Z: () => a });\n    var r = n2(645), o = n2.n(r)()(function(e3) {\n      return e3[1];\n    });\n    o.push([e2.id, \"INPUT:-webkit-autofill,SELECT:-webkit-autofill,TEXTAREA:-webkit-autofill{animation-name:onautofillstart}INPUT:not(:-webkit-autofill),SELECT:not(:-webkit-autofill),TEXTAREA:not(:-webkit-autofill){animation-name:onautofillcancel}@keyframes onautofillstart{}@keyframes onautofillcancel{}\", \"\"]);\n    const a = o;\n  }, 645: (e2) => {\n    e2.exports = function(e3) {\n      var t2 = [];\n      return t2.toString = function() {\n        return this.map(function(t3) {\n          var n2 = e3(t3);\n          return t3[2] ? \"@media \".concat(t3[2], \" {\").concat(n2, \"}\") : n2;\n        }).join(\"\");\n      }, t2.i = function(e4, n2, r) {\n        \"string\" == typeof e4 && (e4 = [[null, e4, \"\"]]);\n        var o = {};\n        if (r)\n          for (var a = 0; a < this.length; a++) {\n            var i = this[a][0];\n            null != i && (o[i] = true);\n          }\n        for (var u = 0; u < e4.length; u++) {\n          var c = [].concat(e4[u]);\n          r && o[c[0]] || (n2 && (c[2] ? c[2] = \"\".concat(n2, \" and \").concat(c[2]) : c[2] = n2), t2.push(c));\n        }\n      }, t2;\n    };\n  }, 810: () => {\n    !function() {\n      if (\"undefined\" != typeof window)\n        try {\n          var e2 = new window.CustomEvent(\"test\", { cancelable: true });\n          if (e2.preventDefault(), true !== e2.defaultPrevented)\n            throw new Error(\"Could not prevent default\");\n        } catch (e3) {\n          var t2 = function(e4, t3) {\n            var n2, r;\n            return (t3 = t3 || {}).bubbles = !!t3.bubbles, t3.cancelable = !!t3.cancelable, (n2 = document.createEvent(\"CustomEvent\")).initCustomEvent(e4, t3.bubbles, t3.cancelable, t3.detail), r = n2.preventDefault, n2.preventDefault = function() {\n              r.call(this);\n              try {\n                Object.defineProperty(this, \"defaultPrevented\", { get: function() {\n                  return true;\n                } });\n              } catch (e5) {\n                this.defaultPrevented = true;\n              }\n            }, n2;\n          };\n          t2.prototype = window.Event.prototype, window.CustomEvent = t2;\n        }\n    }();\n  }, 379: (e2, t2, n2) => {\n    var r, o = function() {\n      var e3 = {};\n      return function(t3) {\n        if (void 0 === e3[t3]) {\n          var n3 = document.querySelector(t3);\n          if (window.HTMLIFrameElement && n3 instanceof window.HTMLIFrameElement)\n            try {\n              n3 = n3.contentDocument.head;\n            } catch (e4) {\n              n3 = null;\n            }\n          e3[t3] = n3;\n        }\n        return e3[t3];\n      };\n    }(), a = [];\n    function i(e3) {\n      for (var t3 = -1, n3 = 0; n3 < a.length; n3++)\n        if (a[n3].identifier === e3) {\n          t3 = n3;\n          break;\n        }\n      return t3;\n    }\n    function u(e3, t3) {\n      for (var n3 = {}, r2 = [], o2 = 0; o2 < e3.length; o2++) {\n        var u2 = e3[o2], c2 = t3.base ? u2[0] + t3.base : u2[0], l2 = n3[c2] || 0, s2 = \"\".concat(c2, \" \").concat(l2);\n        n3[c2] = l2 + 1;\n        var d2 = i(s2), f2 = { css: u2[1], media: u2[2], sourceMap: u2[3] };\n        -1 !== d2 ? (a[d2].references++, a[d2].updater(f2)) : a.push({ identifier: s2, updater: m(f2, t3), references: 1 }), r2.push(s2);\n      }\n      return r2;\n    }\n    function c(e3) {\n      var t3 = document.createElement(\"style\"), r2 = e3.attributes || {};\n      if (void 0 === r2.nonce) {\n        var a2 = n2.nc;\n        a2 && (r2.nonce = a2);\n      }\n      if (Object.keys(r2).forEach(function(e4) {\n        t3.setAttribute(e4, r2[e4]);\n      }), \"function\" == typeof e3.insert)\n        e3.insert(t3);\n      else {\n        var i2 = o(e3.insert || \"head\");\n        if (!i2)\n          throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n        i2.appendChild(t3);\n      }\n      return t3;\n    }\n    var l, s = (l = [], function(e3, t3) {\n      return l[e3] = t3, l.filter(Boolean).join(\"\\n\");\n    });\n    function d(e3, t3, n3, r2) {\n      var o2 = n3 ? \"\" : r2.media ? \"@media \".concat(r2.media, \" {\").concat(r2.css, \"}\") : r2.css;\n      if (e3.styleSheet)\n        e3.styleSheet.cssText = s(t3, o2);\n      else {\n        var a2 = document.createTextNode(o2), i2 = e3.childNodes;\n        i2[t3] && e3.removeChild(i2[t3]), i2.length ? e3.insertBefore(a2, i2[t3]) : e3.appendChild(a2);\n      }\n    }\n    function f(e3, t3, n3) {\n      var r2 = n3.css, o2 = n3.media, a2 = n3.sourceMap;\n      if (o2 ? e3.setAttribute(\"media\", o2) : e3.removeAttribute(\"media\"), a2 && \"undefined\" != typeof btoa && (r2 += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(a2)))), \" */\")), e3.styleSheet)\n        e3.styleSheet.cssText = r2;\n      else {\n        for (; e3.firstChild; )\n          e3.removeChild(e3.firstChild);\n        e3.appendChild(document.createTextNode(r2));\n      }\n    }\n    var v = null, p = 0;\n    function m(e3, t3) {\n      var n3, r2, o2;\n      if (t3.singleton) {\n        var a2 = p++;\n        n3 = v || (v = c(t3)), r2 = d.bind(null, n3, a2, false), o2 = d.bind(null, n3, a2, true);\n      } else\n        n3 = c(t3), r2 = f.bind(null, n3, t3), o2 = function() {\n          !function(e4) {\n            if (null === e4.parentNode)\n              return false;\n            e4.parentNode.removeChild(e4);\n          }(n3);\n        };\n      return r2(e3), function(t4) {\n        if (t4) {\n          if (t4.css === e3.css && t4.media === e3.media && t4.sourceMap === e3.sourceMap)\n            return;\n          r2(e3 = t4);\n        } else\n          o2();\n      };\n    }\n    e2.exports = function(e3, t3) {\n      (t3 = t3 || {}).singleton || \"boolean\" == typeof t3.singleton || (t3.singleton = (void 0 === r && (r = Boolean(window && document && document.all && !window.atob)), r));\n      var n3 = u(e3 = e3 || [], t3);\n      return function(e4) {\n        if (e4 = e4 || [], \"[object Array]\" === Object.prototype.toString.call(e4)) {\n          for (var r2 = 0; r2 < n3.length; r2++) {\n            var o2 = i(n3[r2]);\n            a[o2].references--;\n          }\n          for (var c2 = u(e4, t3), l2 = 0; l2 < n3.length; l2++) {\n            var s2 = i(n3[l2]);\n            0 === a[s2].references && (a[s2].updater(), a.splice(s2, 1));\n          }\n          n3 = c2;\n        }\n      };\n    };\n  } }, t = {};\n  function n(r) {\n    var o = t[r];\n    if (void 0 !== o)\n      return o.exports;\n    var a = t[r] = { id: r, exports: {} };\n    return e[r](a, a.exports, n), a.exports;\n  }\n  n.n = (e2) => {\n    var t2 = e2 && e2.__esModule ? () => e2.default : () => e2;\n    return n.d(t2, { a: t2 }), t2;\n  }, n.d = (e2, t2) => {\n    for (var r in t2)\n      n.o(t2, r) && !n.o(e2, r) && Object.defineProperty(e2, r, { enumerable: true, get: t2[r] });\n  }, n.o = (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2), (() => {\n    var e2 = n(379), t2 = n.n(e2), r = n(454);\n    function o(e3) {\n      if (!e3.hasAttribute(\"autocompleted\")) {\n        e3.setAttribute(\"autocompleted\", \"\");\n        var t3 = new window.CustomEvent(\"onautocomplete\", { bubbles: true, cancelable: true, detail: null });\n        e3.dispatchEvent(t3) || (e3.value = \"\");\n      }\n    }\n    function a(e3) {\n      e3.hasAttribute(\"autocompleted\") && (e3.removeAttribute(\"autocompleted\"), e3.dispatchEvent(new window.CustomEvent(\"onautocomplete\", { bubbles: true, cancelable: false, detail: null })));\n    }\n    t2()(r.Z, { insert: \"head\", singleton: false }), r.Z.locals, n(810), document.addEventListener(\"animationstart\", function(e3) {\n      \"onautofillstart\" === e3.animationName ? o(e3.target) : a(e3.target);\n    }, true), document.addEventListener(\"input\", function(e3) {\n      \"insertReplacementText\" !== e3.inputType && \"data\" in e3 ? a(e3.target) : o(e3.target);\n    }, true);\n  })();\n})();\nclass BaseComponent2 {\n  constructor(element2) {\n    element2 = getElement$1(element2);\n    if (!element2) {\n      return;\n    }\n    this._element = element2;\n    Data$1.setData(this._element, this.constructor.DATA_KEY, this);\n  }\n  dispose() {\n    Data$1.removeData(this._element, this.constructor.DATA_KEY);\n    EventHandler$1.off(this._element, this.constructor.EVENT_KEY);\n    Object.getOwnPropertyNames(this).forEach((propertyName) => {\n      this[propertyName] = null;\n    });\n  }\n  /** Static */\n  static getInstance(element2) {\n    return Data$1.getData(getElement$1(element2), this.DATA_KEY);\n  }\n  static getOrCreateInstance(element2, config = {}) {\n    return this.getInstance(element2) || new this(element2, typeof config === \"object\" ? config : null);\n  }\n  static get NAME() {\n    throw new Error('You have to implement the static method \"NAME\", for each component!');\n  }\n  static get DATA_KEY() {\n    return `mdb.${this.NAME}`;\n  }\n  static get EVENT_KEY() {\n    return `.${this.DATA_KEY}`;\n  }\n}\nconst NAME$6 = \"input\";\nconst DATA_KEY$5 = \"mdb.input\";\nconst CLASSNAME_ACTIVE$1 = \"active\";\nconst CLASSNAME_NOTCH = \"form-notch\";\nconst CLASSNAME_NOTCH_LEADING = \"form-notch-leading\";\nconst CLASSNAME_NOTCH_MIDDLE = \"form-notch-middle\";\nconst CLASSNAME_NOTCH_TRAILING = \"form-notch-trailing\";\nconst CLASSNAME_PLACEHOLDER_ACTIVE = \"placeholder-active\";\nconst CLASSNAME_HELPER = \"form-helper\";\nconst CLASSNAME_COUNTER = \"form-counter\";\nconst SELECTOR_NOTCH = `.${CLASSNAME_NOTCH}`;\nconst SELECTOR_NOTCH_LEADING = `.${CLASSNAME_NOTCH_LEADING}`;\nconst SELECTOR_NOTCH_MIDDLE = `.${CLASSNAME_NOTCH_MIDDLE}`;\nconst SELECTOR_HELPER = `.${CLASSNAME_HELPER}`;\nclass Input extends BaseComponent2 {\n  constructor(element2) {\n    super(element2);\n    this._label = null;\n    this._labelWidth = 0;\n    this._labelMarginLeft = 0;\n    this._notchLeading = null;\n    this._notchMiddle = null;\n    this._notchTrailing = null;\n    this._initiated = false;\n    this._helper = null;\n    this._counter = false;\n    this._counterElement = null;\n    this._maxLength = 0;\n    this._leadingIcon = null;\n    if (this._element) {\n      this.init();\n      Manipulator$1.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, true);\n      bindCallbackEventsIfNeeded(this.constructor);\n    }\n  }\n  // Getters\n  static get NAME() {\n    return NAME$6;\n  }\n  get input() {\n    const inputElement = SelectorEngine$1.findOne(\"input\", this._element) || SelectorEngine$1.findOne(\"textarea\", this._element);\n    return inputElement;\n  }\n  // Public\n  init() {\n    if (this._initiated) {\n      return;\n    }\n    this._getLabelData();\n    this._applyDivs();\n    this._applyNotch();\n    this._activate();\n    this._getHelper();\n    this._getCounter();\n    this._initiated = true;\n  }\n  update() {\n    this._getLabelData();\n    this._getNotchData();\n    this._applyNotch();\n    this._activate();\n    this._getHelper();\n    this._getCounter();\n  }\n  forceActive() {\n    Manipulator$1.addClass(this.input, CLASSNAME_ACTIVE$1);\n  }\n  forceInactive() {\n    Manipulator$1.removeClass(this.input, CLASSNAME_ACTIVE$1);\n  }\n  dispose() {\n    this._removeBorder();\n    Manipulator$1.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`);\n    super.dispose();\n  }\n  // Private\n  /*\n    _getIcons() {\n      this._leadingIcon = SelectorEngine.findOne('i.leading', this._element);\n  \n      if (this._leadingIcon !== null) {\n        this._applyLeadingIcon();\n      }\n    }\n  \n    _applyLeadingIcon() {\n      this._label.innerHTML = ` ${this._label.innerHTML}`;\n      this._label.insertBefore(this._leadingIcon, this._label.firstChild);\n    }\n    */\n  _getLabelData() {\n    this._label = SelectorEngine$1.findOne(\"label\", this._element);\n    if (this._label === null) {\n      this._showPlaceholder();\n    } else {\n      this._getLabelWidth();\n      this._getLabelPositionInInputGroup();\n      this._toggleDefaultDatePlaceholder();\n    }\n  }\n  _getHelper() {\n    this._helper = SelectorEngine$1.findOne(SELECTOR_HELPER, this._element);\n  }\n  _getCounter() {\n    this._counter = Manipulator$1.getDataAttribute(this.input, \"showcounter\");\n    if (this._counter) {\n      this._maxLength = this.input.maxLength;\n      this._showCounter();\n    }\n  }\n  _showCounter() {\n    const counters = SelectorEngine$1.find(\".form-counter\", this._element);\n    if (counters.length > 0) {\n      return;\n    }\n    this._counterElement = document.createElement(\"div\");\n    Manipulator$1.addClass(this._counterElement, CLASSNAME_COUNTER);\n    const actualLength = this.input.value.length;\n    this._counterElement.innerHTML = `${actualLength} / ${this._maxLength}`;\n    this._helper.appendChild(this._counterElement);\n    this._bindCounter();\n  }\n  _bindCounter() {\n    EventHandler$1.on(this.input, \"input\", () => {\n      const actualLength = this.input.value.length;\n      this._counterElement.innerHTML = `${actualLength} / ${this._maxLength}`;\n    });\n  }\n  _toggleDefaultDatePlaceholder(input = this.input) {\n    const type = input.getAttribute(\"type\");\n    const typesWithPlaceholder = [\"date\", \"time\", \"datetime-local\", \"month\", \"week\"];\n    if (!typesWithPlaceholder.includes(type)) {\n      return;\n    }\n    const isInputFocused = document.activeElement === input;\n    if (!isInputFocused && !input.value) {\n      input.style.opacity = 0;\n    } else {\n      input.style.opacity = 1;\n    }\n  }\n  _showPlaceholder() {\n    Manipulator$1.addClass(this.input, CLASSNAME_PLACEHOLDER_ACTIVE);\n  }\n  _getNotchData() {\n    this._notchMiddle = SelectorEngine$1.findOne(SELECTOR_NOTCH_MIDDLE, this._element);\n    this._notchLeading = SelectorEngine$1.findOne(SELECTOR_NOTCH_LEADING, this._element);\n  }\n  _getLabelWidth() {\n    this._labelWidth = this._label.clientWidth * 0.8 + 8;\n  }\n  _getLabelPositionInInputGroup() {\n    this._labelMarginLeft = 0;\n    if (!this._element.classList.contains(\"input-group\"))\n      return;\n    const input = this.input;\n    const prefix = SelectorEngine$1.prev(input, \".input-group-text\")[0];\n    if (prefix === void 0) {\n      this._labelMarginLeft = 0;\n    } else {\n      this._labelMarginLeft = prefix.offsetWidth - 1;\n    }\n  }\n  _applyDivs() {\n    const allNotchWrappers = SelectorEngine$1.find(SELECTOR_NOTCH, this._element);\n    const notchWrapper = element(\"div\");\n    Manipulator$1.addClass(notchWrapper, CLASSNAME_NOTCH);\n    this._notchLeading = element(\"div\");\n    Manipulator$1.addClass(this._notchLeading, CLASSNAME_NOTCH_LEADING);\n    this._notchMiddle = element(\"div\");\n    Manipulator$1.addClass(this._notchMiddle, CLASSNAME_NOTCH_MIDDLE);\n    this._notchTrailing = element(\"div\");\n    Manipulator$1.addClass(this._notchTrailing, CLASSNAME_NOTCH_TRAILING);\n    if (allNotchWrappers.length >= 1) {\n      return;\n    }\n    notchWrapper.append(this._notchLeading);\n    notchWrapper.append(this._notchMiddle);\n    notchWrapper.append(this._notchTrailing);\n    this._element.append(notchWrapper);\n  }\n  _applyNotch() {\n    this._notchMiddle.style.width = `${this._labelWidth}px`;\n    this._notchLeading.style.width = `${this._labelMarginLeft + 9}px`;\n    if (this._label === null)\n      return;\n    this._label.style.marginLeft = `${this._labelMarginLeft}px`;\n  }\n  _removeBorder() {\n    const border = SelectorEngine$1.findOne(SELECTOR_NOTCH, this._element);\n    if (border)\n      border.remove();\n  }\n  _activate(event) {\n    onDOMContentLoaded(() => {\n      this._getElements(event);\n      if (!this._element) {\n        return;\n      }\n      const input = event ? event.target : this.input;\n      if (input.value !== \"\") {\n        Manipulator$1.addClass(input, CLASSNAME_ACTIVE$1);\n      }\n      this._toggleDefaultDatePlaceholder(input);\n    });\n  }\n  _getElements(event) {\n    let initialized;\n    if (event) {\n      this._element = event.target.parentNode;\n      this._label = SelectorEngine$1.findOne(\"label\", this._element);\n      initialized = Manipulator$1.getDataAttribute(\n        this._element,\n        `${this.constructor.NAME}-initialized`\n      );\n    }\n    if (!initialized) {\n      return;\n    }\n    if (event && this._label) {\n      const prevLabelWidth = this._labelWidth;\n      this._getLabelData();\n      if (prevLabelWidth !== this._labelWidth) {\n        this._notchMiddle = SelectorEngine$1.findOne(\".form-notch-middle\", event.target.parentNode);\n        this._notchLeading = SelectorEngine$1.findOne(\n          SELECTOR_NOTCH_LEADING,\n          event.target.parentNode\n        );\n        this._applyNotch();\n      }\n    }\n  }\n  _deactivate(event) {\n    const input = event ? event.target : this.input;\n    if (input.value === \"\") {\n      input.classList.remove(CLASSNAME_ACTIVE$1);\n    }\n    this._toggleDefaultDatePlaceholder(input);\n  }\n  static activate(instance) {\n    return function(event) {\n      instance._activate(event);\n    };\n  }\n  static deactivate(instance) {\n    return function(event) {\n      instance._deactivate(event);\n    };\n  }\n  static jQueryInterface(config, options) {\n    return this.each(function() {\n      let data = Data$1.getData(this, DATA_KEY$5);\n      const _config = typeof config === \"object\" && config;\n      if (!data && /dispose/.test(config)) {\n        return;\n      }\n      if (!data) {\n        data = new Input(this, _config);\n      }\n      if (typeof config === \"string\") {\n        if (typeof data[config] === \"undefined\") {\n          throw new TypeError(`No method named \"${config}\"`);\n        }\n        data[config](options);\n      }\n    });\n  }\n}\nconst NAME$5 = \"collapse\";\nconst DATA_KEY$4 = \"bs.collapse\";\nconst EVENT_KEY$2 = `.${DATA_KEY$4}`;\nconst EVENT_SHOW$2 = `show${EVENT_KEY$2}`;\nconst EVENT_SHOWN$2 = `shown${EVENT_KEY$2}`;\nconst EVENT_HIDE$2 = `hide${EVENT_KEY$2}`;\nconst EVENT_HIDDEN$2 = `hidden${EVENT_KEY$2}`;\nconst CLASS_NAME_SHOW$1 = \"show\";\nconst CLASS_NAME_COLLAPSE = \"collapse\";\nconst CLASS_NAME_COLLAPSING = \"collapsing\";\nconst CLASS_NAME_COLLAPSED = \"collapsed\";\nconst CLASS_NAME_DEEPER_CHILDREN = `:scope .${CLASS_NAME_COLLAPSE} .${CLASS_NAME_COLLAPSE}`;\nconst CLASS_NAME_HORIZONTAL = \"collapse-horizontal\";\nconst WIDTH = \"width\";\nconst HEIGHT = \"height\";\nconst SELECTOR_ACTIVES = \".collapse.show, .collapse.collapsing\";\nconst SELECTOR_DATA_TOGGLE$1 = \"[data-mdb-collapse-init]\";\nconst Default$3 = {\n  parent: null,\n  toggle: true\n};\nconst DefaultType$3 = {\n  parent: \"(null|element)\",\n  toggle: \"boolean\"\n};\nlet Collapse$1 = class Collapse extends BaseComponent$1 {\n  constructor(element2, config) {\n    super(element2, config);\n    this._isTransitioning = false;\n    this._triggerArray = [];\n    const toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$1);\n    for (const elem of toggleList) {\n      const selector = SelectorEngine.getSelectorFromElement(elem);\n      const filterElement = SelectorEngine.find(selector).filter(\n        (foundElement) => foundElement === this._element\n      );\n      if (selector !== null && filterElement.length) {\n        this._triggerArray.push(elem);\n      }\n    }\n    this._initializeChildren();\n    if (!this._config.parent) {\n      this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());\n    }\n    if (this._config.toggle) {\n      this.toggle();\n    }\n  }\n  // Getters\n  static get Default() {\n    return Default$3;\n  }\n  static get DefaultType() {\n    return DefaultType$3;\n  }\n  static get NAME() {\n    return NAME$5;\n  }\n  // Public\n  toggle() {\n    if (this._isShown()) {\n      this.hide();\n    } else {\n      this.show();\n    }\n  }\n  show() {\n    if (this._isTransitioning || this._isShown()) {\n      return;\n    }\n    let activeChildren = [];\n    if (this._config.parent) {\n      activeChildren = this._getFirstLevelChildren(SELECTOR_ACTIVES).filter((element2) => element2 !== this._element).map((element2) => Collapse.getOrCreateInstance(element2, { toggle: false }));\n    }\n    if (activeChildren.length && activeChildren[0]._isTransitioning) {\n      return;\n    }\n    const startEvent = EventHandler.trigger(this._element, EVENT_SHOW$2);\n    if (startEvent.defaultPrevented) {\n      return;\n    }\n    for (const activeInstance of activeChildren) {\n      activeInstance.hide();\n    }\n    const dimension = this._getDimension();\n    this._element.classList.remove(CLASS_NAME_COLLAPSE);\n    this._element.classList.add(CLASS_NAME_COLLAPSING);\n    this._element.style[dimension] = 0;\n    this._addAriaAndCollapsedClass(this._triggerArray, true);\n    this._isTransitioning = true;\n    const complete = () => {\n      this._isTransitioning = false;\n      this._element.classList.remove(CLASS_NAME_COLLAPSING);\n      this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$1);\n      this._element.style[dimension] = \"\";\n      EventHandler.trigger(this._element, EVENT_SHOWN$2);\n    };\n    const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);\n    const scrollSize = `scroll${capitalizedDimension}`;\n    this._queueCallback(complete, this._element, true);\n    this._element.style[dimension] = `${this._element[scrollSize]}px`;\n  }\n  hide() {\n    if (this._isTransitioning || !this._isShown()) {\n      return;\n    }\n    const startEvent = EventHandler.trigger(this._element, EVENT_HIDE$2);\n    if (startEvent.defaultPrevented) {\n      return;\n    }\n    const dimension = this._getDimension();\n    this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;\n    reflow(this._element);\n    this._element.classList.add(CLASS_NAME_COLLAPSING);\n    this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$1);\n    for (const trigger of this._triggerArray) {\n      const element2 = SelectorEngine.getElementFromSelector(trigger);\n      if (element2 && !this._isShown(element2)) {\n        this._addAriaAndCollapsedClass([trigger], false);\n      }\n    }\n    this._isTransitioning = true;\n    const complete = () => {\n      this._isTransitioning = false;\n      this._element.classList.remove(CLASS_NAME_COLLAPSING);\n      this._element.classList.add(CLASS_NAME_COLLAPSE);\n      EventHandler.trigger(this._element, EVENT_HIDDEN$2);\n    };\n    this._element.style[dimension] = \"\";\n    this._queueCallback(complete, this._element, true);\n  }\n  _isShown(element2 = this._element) {\n    return element2.classList.contains(CLASS_NAME_SHOW$1);\n  }\n  // Private\n  _configAfterMerge(config) {\n    config.toggle = Boolean(config.toggle);\n    config.parent = getElement(config.parent);\n    return config;\n  }\n  _getDimension() {\n    return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;\n  }\n  _initializeChildren() {\n    if (!this._config.parent) {\n      return;\n    }\n    const children = this._getFirstLevelChildren(SELECTOR_DATA_TOGGLE$1);\n    for (const element2 of children) {\n      const selected = SelectorEngine.getElementFromSelector(element2);\n      if (selected) {\n        this._addAriaAndCollapsedClass([element2], this._isShown(selected));\n      }\n    }\n  }\n  _getFirstLevelChildren(selector) {\n    const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);\n    return SelectorEngine.find(selector, this._config.parent).filter(\n      (element2) => !children.includes(element2)\n    );\n  }\n  _addAriaAndCollapsedClass(triggerArray, isOpen) {\n    if (!triggerArray.length) {\n      return;\n    }\n    for (const element2 of triggerArray) {\n      element2.classList.toggle(CLASS_NAME_COLLAPSED, !isOpen);\n      element2.setAttribute(\"aria-expanded\", isOpen);\n    }\n  }\n  // Static\n  static jQueryInterface(config) {\n    const _config = {};\n    if (typeof config === \"string\" && /show|hide/.test(config)) {\n      _config.toggle = false;\n    }\n    return this.each(function() {\n      const data = Collapse.getOrCreateInstance(this, _config);\n      if (typeof config === \"string\") {\n        if (typeof data[config] === \"undefined\") {\n          throw new TypeError(`No method named \"${config}\"`);\n        }\n        data[config]();\n      }\n    });\n  }\n};\nconst NAME$4 = \"collapse\";\nconst EVENT_SHOW_BS = \"show.bs.collapse\";\nconst EVENT_SHOWN_BS = \"shown.bs.collapse\";\nconst EVENT_HIDE_BS = \"hide.bs.collapse\";\nconst EVENT_HIDDEN_BS = \"hidden.bs.collapse\";\nconst EXTENDED_EVENTS = [{ name: \"show\" }, { name: \"shown\" }, { name: \"hide\" }, { name: \"hidden\" }];\nclass Collapse2 extends Collapse$1 {\n  constructor(element2, data = {}) {\n    super(element2, data);\n    this._init();\n    Manipulator$1.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, true);\n    bindCallbackEventsIfNeeded(this.constructor);\n  }\n  dispose() {\n    EventHandler$1.off(this._element, EVENT_SHOW_BS);\n    EventHandler$1.off(this._element, EVENT_SHOWN_BS);\n    EventHandler$1.off(this._element, EVENT_HIDE_BS);\n    EventHandler$1.off(this._element, EVENT_HIDDEN_BS);\n    Manipulator$1.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`);\n    super.dispose();\n  }\n  // Getters\n  static get NAME() {\n    return NAME$4;\n  }\n  // Private\n  _init() {\n    this._bindMdbEvents();\n  }\n  _bindMdbEvents() {\n    EventHandler$1.extend(this._element, EXTENDED_EVENTS, NAME$4);\n  }\n}\nconst NAME$3 = \"dropdown\";\nconst DATA_KEY$3 = \"bs.dropdown\";\nconst EVENT_KEY$1 = `.${DATA_KEY$3}`;\nconst ESCAPE_KEY = \"Escape\";\nconst TAB_KEY = \"Tab\";\nconst ARROW_UP_KEY = \"ArrowUp\";\nconst ARROW_DOWN_KEY = \"ArrowDown\";\nconst RIGHT_MOUSE_BUTTON = 2;\nconst EVENT_HIDE$1 = `hide${EVENT_KEY$1}`;\nconst EVENT_HIDDEN$1 = `hidden${EVENT_KEY$1}`;\nconst EVENT_SHOW$1 = `show${EVENT_KEY$1}`;\nconst EVENT_SHOWN$1 = `shown${EVENT_KEY$1}`;\nconst CLASS_NAME_SHOW = \"show\";\nconst CLASS_NAME_DROPUP = \"dropup\";\nconst CLASS_NAME_DROPEND = \"dropend\";\nconst CLASS_NAME_DROPSTART = \"dropstart\";\nconst CLASS_NAME_DROPUP_CENTER = \"dropup-center\";\nconst CLASS_NAME_DROPDOWN_CENTER = \"dropdown-center\";\nconst SELECTOR_DATA_TOGGLE = \"[data-mdb-dropdown-initialized]:not(.disabled):not(:disabled)\";\nconst SELECTOR_DATA_TOGGLE_SHOWN = `${SELECTOR_DATA_TOGGLE}.${CLASS_NAME_SHOW}`;\nconst SELECTOR_MENU = \".dropdown-menu\";\nconst SELECTOR_NAVBAR = \".navbar\";\nconst SELECTOR_NAVBAR_NAV = \".navbar-nav\";\nconst SELECTOR_VISIBLE_ITEMS = \".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)\";\nconst PLACEMENT_TOP = isRTL() ? \"top-end\" : \"top-start\";\nconst PLACEMENT_TOPEND = isRTL() ? \"top-start\" : \"top-end\";\nconst PLACEMENT_BOTTOM = isRTL() ? \"bottom-end\" : \"bottom-start\";\nconst PLACEMENT_BOTTOMEND = isRTL() ? \"bottom-start\" : \"bottom-end\";\nconst PLACEMENT_RIGHT = isRTL() ? \"left-start\" : \"right-start\";\nconst PLACEMENT_LEFT = isRTL() ? \"right-start\" : \"left-start\";\nconst PLACEMENT_TOPCENTER = \"top\";\nconst PLACEMENT_BOTTOMCENTER = \"bottom\";\nconst Default$2 = {\n  autoClose: true,\n  boundary: \"clippingParents\",\n  display: \"dynamic\",\n  offset: [0, 2],\n  popperConfig: null,\n  reference: \"toggle\"\n};\nconst DefaultType$2 = {\n  autoClose: \"(boolean|string)\",\n  boundary: \"(string|element)\",\n  display: \"string\",\n  offset: \"(array|string|function)\",\n  popperConfig: \"(null|object|function)\",\n  reference: \"(string|element|object)\"\n};\nlet Dropdown$1 = class Dropdown extends BaseComponent$1 {\n  constructor(element2, config) {\n    super(element2, config);\n    this._popper = null;\n    this._parent = this._element.parentNode;\n    this._menu = SelectorEngine.next(this._element, SELECTOR_MENU)[0] || SelectorEngine.prev(this._element, SELECTOR_MENU)[0] || SelectorEngine.findOne(SELECTOR_MENU, this._parent);\n    this._inNavbar = this._detectNavbar();\n  }\n  // Getters\n  static get Default() {\n    return Default$2;\n  }\n  static get DefaultType() {\n    return DefaultType$2;\n  }\n  static get NAME() {\n    return NAME$3;\n  }\n  // Public\n  toggle() {\n    return this._isShown() ? this.hide() : this.show();\n  }\n  show() {\n    if (isDisabled(this._element) || this._isShown()) {\n      return;\n    }\n    const relatedTarget = {\n      relatedTarget: this._element\n    };\n    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$1, relatedTarget);\n    if (showEvent.defaultPrevented) {\n      return;\n    }\n    this._createPopper();\n    if (\"ontouchstart\" in document.documentElement && !this._parent.closest(SELECTOR_NAVBAR_NAV)) {\n      for (const element2 of [].concat(...document.body.children)) {\n        EventHandler.on(element2, \"mouseover\", noop);\n      }\n    }\n    this._element.focus();\n    this._element.setAttribute(\"aria-expanded\", true);\n    this._menu.classList.add(CLASS_NAME_SHOW);\n    this._element.classList.add(CLASS_NAME_SHOW);\n    EventHandler.trigger(this._element, EVENT_SHOWN$1, relatedTarget);\n  }\n  hide() {\n    if (isDisabled(this._element) || !this._isShown()) {\n      return;\n    }\n    const relatedTarget = {\n      relatedTarget: this._element\n    };\n    this._completeHide(relatedTarget);\n  }\n  dispose() {\n    if (this._popper) {\n      this._popper.destroy();\n    }\n    super.dispose();\n  }\n  update() {\n    this._inNavbar = this._detectNavbar();\n    if (this._popper) {\n      this._popper.update();\n    }\n  }\n  // Private\n  _completeHide(relatedTarget) {\n    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$1, relatedTarget);\n    if (hideEvent.defaultPrevented) {\n      return;\n    }\n    if (\"ontouchstart\" in document.documentElement) {\n      for (const element2 of [].concat(...document.body.children)) {\n        EventHandler.off(element2, \"mouseover\", noop);\n      }\n    }\n    if (this._popper) {\n      this._popper.destroy();\n    }\n    this._menu.classList.remove(CLASS_NAME_SHOW);\n    this._element.classList.remove(CLASS_NAME_SHOW);\n    this._element.setAttribute(\"aria-expanded\", \"false\");\n    Manipulator.removeDataAttribute(this._menu, \"popper\");\n    EventHandler.trigger(this._element, EVENT_HIDDEN$1, relatedTarget);\n  }\n  _getConfig(config) {\n    config = super._getConfig(config);\n    if (typeof config.reference === \"object\" && !isElement$1(config.reference) && typeof config.reference.getBoundingClientRect !== \"function\") {\n      throw new TypeError(\n        `${NAME$3.toUpperCase()}: Option \"reference\" provided type \"object\" without a required \"getBoundingClientRect\" method.`\n      );\n    }\n    return config;\n  }\n  _createPopper() {\n    if (typeof Popper === \"undefined\") {\n      throw new TypeError(\"Bootstrap's dropdowns require Popper (https://popper.js.org)\");\n    }\n    let referenceElement = this._element;\n    if (this._config.reference === \"parent\") {\n      referenceElement = this._parent;\n    } else if (isElement$1(this._config.reference)) {\n      referenceElement = getElement(this._config.reference);\n    } else if (typeof this._config.reference === \"object\") {\n      referenceElement = this._config.reference;\n    }\n    const popperConfig = this._getPopperConfig();\n    this._popper = createPopper(referenceElement, this._menu, popperConfig);\n  }\n  _isShown() {\n    return this._menu.classList.contains(CLASS_NAME_SHOW);\n  }\n  _getPlacement() {\n    const parentDropdown = this._parent;\n    if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {\n      return PLACEMENT_RIGHT;\n    }\n    if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {\n      return PLACEMENT_LEFT;\n    }\n    if (parentDropdown.classList.contains(CLASS_NAME_DROPUP_CENTER)) {\n      return PLACEMENT_TOPCENTER;\n    }\n    if (parentDropdown.classList.contains(CLASS_NAME_DROPDOWN_CENTER)) {\n      return PLACEMENT_BOTTOMCENTER;\n    }\n    const isEnd = getComputedStyle(this._menu).getPropertyValue(\"--mdb-position\").trim() === \"end\";\n    if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {\n      return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;\n    }\n    return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;\n  }\n  _detectNavbar() {\n    return this._element.closest(SELECTOR_NAVBAR) !== null;\n  }\n  _getOffset() {\n    const { offset: offset2 } = this._config;\n    if (typeof offset2 === \"string\") {\n      return offset2.split(\",\").map((value) => Number.parseInt(value, 10));\n    }\n    if (typeof offset2 === \"function\") {\n      return (popperData) => offset2(popperData, this._element);\n    }\n    return offset2;\n  }\n  _getPopperConfig() {\n    const defaultBsPopperConfig = {\n      placement: this._getPlacement(),\n      modifiers: [\n        {\n          name: \"preventOverflow\",\n          options: {\n            boundary: this._config.boundary\n          }\n        },\n        {\n          name: \"offset\",\n          options: {\n            offset: this._getOffset()\n          }\n        }\n      ]\n    };\n    if (this._inNavbar || this._config.display === \"static\") {\n      Manipulator.setDataAttribute(this._menu, \"popper\", \"static\");\n      defaultBsPopperConfig.modifiers = [\n        {\n          name: \"applyStyles\",\n          enabled: false\n        }\n      ];\n    }\n    return {\n      ...defaultBsPopperConfig,\n      ...execute(this._config.popperConfig, [defaultBsPopperConfig])\n    };\n  }\n  _selectMenuItem({ key, target }) {\n    const items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter(\n      (element2) => isVisible(element2)\n    );\n    if (!items.length) {\n      return;\n    }\n    getNextActiveElement(items, target, key === ARROW_DOWN_KEY, !items.includes(target)).focus();\n  }\n  // Static\n  static jQueryInterface(config) {\n    return this.each(function() {\n      const data = Dropdown.getOrCreateInstance(this, config);\n      if (typeof config !== \"string\") {\n        return;\n      }\n      if (typeof data[config] === \"undefined\") {\n        throw new TypeError(`No method named \"${config}\"`);\n      }\n      data[config]();\n    });\n  }\n  static clearMenus(event) {\n    if (event.button === RIGHT_MOUSE_BUTTON || event.type === \"keyup\" && event.key !== TAB_KEY) {\n      return;\n    }\n    const openToggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE_SHOWN);\n    for (const toggle of openToggles) {\n      const context = Dropdown.getInstance(toggle);\n      if (!context || context._config.autoClose === false) {\n        continue;\n      }\n      const composedPath = event.composedPath();\n      const isMenuTarget = composedPath.includes(context._menu);\n      if (composedPath.includes(context._element) || context._config.autoClose === \"inside\" && !isMenuTarget || context._config.autoClose === \"outside\" && isMenuTarget) {\n        continue;\n      }\n      if (context._menu.contains(event.target) && (event.type === \"keyup\" && event.key === TAB_KEY || /input|select|option|textarea|form/i.test(event.target.tagName))) {\n        continue;\n      }\n      const relatedTarget = { relatedTarget: context._element };\n      if (event.type === \"click\") {\n        relatedTarget.clickEvent = event;\n      }\n      context._completeHide(relatedTarget);\n    }\n  }\n  static dataApiKeydownHandler(event) {\n    const isInput = /input|textarea/i.test(event.target.tagName);\n    const isEscapeEvent = event.key === ESCAPE_KEY;\n    const isUpOrDownEvent = [ARROW_UP_KEY, ARROW_DOWN_KEY].includes(event.key);\n    if (!isUpOrDownEvent && !isEscapeEvent) {\n      return;\n    }\n    if (isInput && !isEscapeEvent) {\n      return;\n    }\n    event.preventDefault();\n    const getToggleButton = this.matches(SELECTOR_DATA_TOGGLE) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE)[0] || SelectorEngine.next(this, SELECTOR_DATA_TOGGLE)[0] || SelectorEngine.findOne(SELECTOR_DATA_TOGGLE, event.delegateTarget.parentNode);\n    const instance = Dropdown.getOrCreateInstance(getToggleButton);\n    if (isUpOrDownEvent) {\n      event.stopPropagation();\n      instance.show();\n      instance._selectMenuItem(event);\n      return;\n    }\n    if (instance._isShown()) {\n      event.stopPropagation();\n      instance.hide();\n      getToggleButton.focus();\n    }\n  }\n};\nconst NAME$2 = \"dropdown\";\nconst DATA_KEY$2 = `mdb.${NAME$2}`;\nconst EVENT_KEY = `.${DATA_KEY$2}`;\nconst Default$1 = {\n  offset: [0, 2],\n  flip: true,\n  boundary: \"clippingParents\",\n  reference: \"toggle\",\n  display: \"dynamic\",\n  popperConfig: null,\n  dropdownAnimation: \"on\"\n};\nconst DefaultType$1 = {\n  offset: \"(array|string|function)\",\n  flip: \"boolean\",\n  boundary: \"(string|element)\",\n  reference: \"(string|element|object)\",\n  display: \"string\",\n  popperConfig: \"(null|object|function)\",\n  dropdownAnimation: \"string\"\n};\nconst EVENT_HIDE = \"hide.bs.dropdown\";\nconst EVENT_HIDDEN = \"hidden.bs.dropdown\";\nconst EVENT_SHOW = \"show.bs.dropdown\";\nconst EVENT_SHOWN = \"shown.bs.dropdown\";\nconst EVENT_HIDE_MDB = `hide${EVENT_KEY}`;\nconst EVENT_HIDDEN_MDB = `hidden${EVENT_KEY}`;\nconst EVENT_SHOW_MDB = `show${EVENT_KEY}`;\nconst EVENT_SHOWN_MDB = `shown${EVENT_KEY}`;\nconst ANIMATION_CLASS = \"animation\";\nconst ANIMATION_SHOW_CLASS = \"fade-in\";\nconst ANIMATION_HIDE_CLASS = \"fade-out\";\nclass Dropdown2 extends Dropdown$1 {\n  constructor(element2, data) {\n    super(element2, data);\n    this._config = this._getConfig(data);\n    this._menuStyle = \"\";\n    this._popperPlacement = \"\";\n    this._mdbPopperConfig = \"\";\n    const isPrefersReducedMotionSet = window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches;\n    if (this._config.dropdownAnimation === \"on\" && !isPrefersReducedMotionSet) {\n      this._init();\n    }\n    Manipulator$1.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, true);\n    bindCallbackEventsIfNeeded(this.constructor);\n  }\n  dispose() {\n    EventHandler$1.off(this._element, EVENT_SHOW);\n    EventHandler$1.off(this._parent, EVENT_SHOWN);\n    EventHandler$1.off(this._parent, EVENT_HIDE);\n    EventHandler$1.off(this._parent, EVENT_HIDDEN);\n    Manipulator$1.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`);\n    super.dispose();\n  }\n  // Getters\n  static get NAME() {\n    return NAME$2;\n  }\n  // Private\n  _init() {\n    this._bindShowEvent();\n    this._bindShownEvent();\n    this._bindHideEvent();\n    this._bindHiddenEvent();\n  }\n  _getConfig(options) {\n    const config = {\n      ...Default$1,\n      ...Manipulator$1.getDataAttributes(this._element),\n      ...options\n    };\n    typeCheckConfig(NAME$2, config, DefaultType$1);\n    return config;\n  }\n  _getOffset() {\n    const { offset: offset2 } = this._config;\n    if (typeof offset2 === \"string\") {\n      return offset2.split(\",\").map((val) => Number.parseInt(val, 10));\n    }\n    if (typeof offset2 === \"function\") {\n      return (popperData) => offset2(popperData, this._element);\n    }\n    return offset2;\n  }\n  _getPopperConfig() {\n    const popperConfig = {\n      placement: this._getPlacement(),\n      modifiers: [\n        {\n          name: \"preventOverflow\",\n          options: {\n            altBoundary: this._config.flip,\n            boundary: this._config.boundary\n          }\n        },\n        {\n          name: \"offset\",\n          options: {\n            offset: this._getOffset()\n          }\n        }\n      ]\n    };\n    if (this._config.display === \"static\") {\n      Manipulator$1.setDataAttribute(this._menu, \"popper\", \"static\");\n      popperConfig.modifiers = [\n        {\n          name: \"applyStyles\",\n          enabled: false\n        }\n      ];\n    }\n    return {\n      ...popperConfig,\n      /* eslint no-extra-parens: \"off\" */\n      ...typeof this._config.popperConfig === \"function\" ? this._config.popperConfig(popperConfig) : this._config.popperConfig\n    };\n  }\n  _bindShowEvent() {\n    EventHandler$1.on(this._element, EVENT_SHOW, (e) => {\n      const showEvent = EventHandler$1.trigger(this._element, EVENT_SHOW_MDB, {\n        relatedTarget: e.relatedTarget\n      });\n      if (showEvent.defaultPrevented) {\n        e.preventDefault();\n        return;\n      }\n      this._dropdownAnimationStart(\"show\");\n    });\n  }\n  _bindShownEvent() {\n    EventHandler$1.on(this._parent, EVENT_SHOWN, (e) => {\n      const shownEvent = EventHandler$1.trigger(this._parent, EVENT_SHOWN_MDB, {\n        relatedTarget: e.relatedTarget\n      });\n      if (shownEvent.defaultPrevented) {\n        e.preventDefault();\n        return;\n      }\n    });\n  }\n  _bindHideEvent() {\n    EventHandler$1.on(this._parent, EVENT_HIDE, (e) => {\n      const hideEvent = EventHandler$1.trigger(this._parent, EVENT_HIDE_MDB, {\n        relatedTarget: e.relatedTarget\n      });\n      if (hideEvent.defaultPrevented) {\n        e.preventDefault();\n        return;\n      }\n      this._menuStyle = this._menu.style.cssText;\n      this._popperPlacement = this._menu.getAttribute(\"data-popper-placement\");\n      this._mdbPopperConfig = this._menu.getAttribute(\"data-mdb-popper\");\n    });\n  }\n  _bindHiddenEvent() {\n    EventHandler$1.on(this._parent, EVENT_HIDDEN, (e) => {\n      const hiddenEvent = EventHandler$1.trigger(this._parent, EVENT_HIDDEN_MDB, {\n        relatedTarget: e.relatedTarget\n      });\n      if (hiddenEvent.defaultPrevented) {\n        e.preventDefault();\n        return;\n      }\n      if (this._config.display !== \"static\" && this._menuStyle !== \"\") {\n        this._menu.style.cssText = this._menuStyle;\n      }\n      this._menu.setAttribute(\"data-popper-placement\", this._popperPlacement);\n      this._menu.setAttribute(\"data-mdb-popper\", this._mdbPopperConfig);\n      this._dropdownAnimationStart(\"hide\");\n    });\n  }\n  _dropdownAnimationStart(action) {\n    switch (action) {\n      case \"show\":\n        this._menu.classList.add(ANIMATION_CLASS, ANIMATION_SHOW_CLASS);\n        this._menu.classList.remove(ANIMATION_HIDE_CLASS);\n        break;\n      default:\n        this._menu.classList.add(ANIMATION_CLASS, ANIMATION_HIDE_CLASS);\n        this._menu.classList.remove(ANIMATION_SHOW_CLASS);\n        break;\n    }\n    this._bindAnimationEnd();\n  }\n  _bindAnimationEnd() {\n    EventHandler$1.one(this._menu, \"animationend\", () => {\n      this._menu.classList.remove(ANIMATION_CLASS, ANIMATION_HIDE_CLASS, ANIMATION_SHOW_CLASS);\n    });\n  }\n}\nconst NAME$1 = \"ripple\";\nconst DATA_KEY$1 = \"mdb.ripple\";\nconst CLASSNAME_RIPPLE = \"ripple-surface\";\nconst CLASSNAME_RIPPLE_WAVE = \"ripple-wave\";\nconst CLASSNAME_RIPPLE_WRAPPER = \"input-wrapper\";\nconst SELECTOR_BTN = \".btn\";\nconst SELECTOR_COMPONENT = [SELECTOR_BTN, `[data-mdb-${NAME$1}-init]`];\nconst CLASSNAME_UNBOUND = \"ripple-surface-unbound\";\nconst GRADIENT = \"rgba({{color}}, 0.2) 0, rgba({{color}}, 0.3) 40%, rgba({{color}}, 0.4) 50%, rgba({{color}}, 0.5) 60%, rgba({{color}}, 0) 70%\";\nconst DEFAULT_RIPPLE_COLOR = [0, 0, 0];\nconst BOOTSTRAP_COLORS = [\n  \"primary\",\n  \"secondary\",\n  \"success\",\n  \"danger\",\n  \"warning\",\n  \"info\",\n  \"light\",\n  \"dark\"\n];\nconst TRANSITION_BREAK_OPACITY = 0.5;\nconst Default = {\n  rippleCentered: false,\n  rippleColor: \"\",\n  rippleDuration: \"500ms\",\n  rippleRadius: 0,\n  rippleUnbound: false\n};\nconst DefaultType = {\n  rippleCentered: \"boolean\",\n  rippleColor: \"string\",\n  rippleDuration: \"string\",\n  rippleRadius: \"number\",\n  rippleUnbound: \"boolean\"\n};\nclass Ripple extends BaseComponent2 {\n  constructor(element2, options) {\n    super(element2);\n    this._options = this._getConfig(options);\n    if (this._element) {\n      Manipulator$1.addClass(this._element, CLASSNAME_RIPPLE);\n      Manipulator$1.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, true);\n      bindCallbackEventsIfNeeded(this.constructor);\n    }\n    this._clickHandler = this._createRipple.bind(this);\n    this._rippleTimer = null;\n    this._isMinWidthSet = false;\n    this._rippleInSpan = false;\n    this.init();\n  }\n  // Getters\n  static get NAME() {\n    return NAME$1;\n  }\n  // Public\n  init() {\n    this._addClickEvent(this._element);\n  }\n  dispose() {\n    EventHandler$1.off(this._element, \"mousedown\", this._clickHandler);\n    Manipulator$1.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`);\n    super.dispose();\n  }\n  // Private\n  _autoInit(event) {\n    SELECTOR_COMPONENT.forEach((selector) => {\n      const target = SelectorEngine$1.closest(event.target, selector);\n      if (target) {\n        this._element = SelectorEngine$1.closest(event.target, selector);\n      }\n    });\n    const dataAttributes = Manipulator$1.getDataAttributes(this._element);\n    if (this._element.classList.contains(\"btn\") && dataAttributes.rippleInit === false) {\n      return;\n    }\n    this._options = this._getConfig();\n    if (this._element.tagName.toLowerCase() === \"input\") {\n      const parent = this._element.parentNode;\n      this._rippleInSpan = true;\n      if (parent.tagName.toLowerCase() === \"span\" && parent.classList.contains(CLASSNAME_RIPPLE)) {\n        this._element = parent;\n      } else {\n        const shadow = getComputedStyle(this._element).boxShadow;\n        const btn = this._element;\n        const wrapper = document.createElement(\"span\");\n        if (btn.classList.contains(\"btn-block\")) {\n          wrapper.style.display = \"block\";\n        }\n        EventHandler$1.one(wrapper, \"mouseup\", (e) => {\n          if (e.button === 0) {\n            btn.click();\n          }\n        });\n        wrapper.classList.add(CLASSNAME_RIPPLE, CLASSNAME_RIPPLE_WRAPPER);\n        Manipulator$1.addStyle(wrapper, {\n          border: 0,\n          \"box-shadow\": shadow\n        });\n        parent.replaceChild(wrapper, this._element);\n        wrapper.appendChild(this._element);\n        this._element = wrapper;\n      }\n      this._element.focus();\n    }\n    if (!this._element.style.minWidth) {\n      Manipulator$1.style(this._element, { \"min-width\": `${getComputedStyle(this._element).width}` });\n      this._isMinWidthSet = true;\n    }\n    Manipulator$1.addClass(this._element, CLASSNAME_RIPPLE);\n    this._createRipple(event);\n  }\n  _addClickEvent(target) {\n    EventHandler$1.on(target, \"mousedown\", this._clickHandler);\n  }\n  _getEventLayer(event) {\n    const x = Math.round(event.clientX - event.target.getBoundingClientRect().x);\n    const y = Math.round(event.clientY - event.target.getBoundingClientRect().y);\n    return { layerX: x, layerY: y };\n  }\n  _createRipple(event) {\n    if (this._element === null) {\n      return;\n    }\n    if (!Manipulator$1.hasClass(this._element, CLASSNAME_RIPPLE)) {\n      Manipulator$1.addClass(this._element, CLASSNAME_RIPPLE);\n    }\n    const { layerX, layerY } = this._getEventLayer(event);\n    const offsetX = layerX;\n    const offsetY = layerY;\n    const height = this._element.offsetHeight;\n    const width = this._element.offsetWidth;\n    const duration = this._durationToMsNumber(this._options.rippleDuration);\n    const diameterOptions = {\n      offsetX: this._options.rippleCentered ? height / 2 : offsetX,\n      offsetY: this._options.rippleCentered ? width / 2 : offsetY,\n      height,\n      width\n    };\n    const diameter = this._getDiameter(diameterOptions);\n    const radiusValue = this._options.rippleRadius || diameter / 2;\n    const opacity = {\n      delay: duration * TRANSITION_BREAK_OPACITY,\n      duration: duration - duration * TRANSITION_BREAK_OPACITY\n    };\n    const styles = {\n      left: this._options.rippleCentered ? `${width / 2 - radiusValue}px` : `${offsetX - radiusValue}px`,\n      top: this._options.rippleCentered ? `${height / 2 - radiusValue}px` : `${offsetY - radiusValue}px`,\n      height: `${this._options.rippleRadius * 2 || diameter}px`,\n      width: `${this._options.rippleRadius * 2 || diameter}px`,\n      transitionDelay: `0s, ${opacity.delay}ms`,\n      transitionDuration: `${duration}ms, ${opacity.duration}ms`\n    };\n    const rippleHTML = element(\"div\");\n    this._createHTMLRipple({ wrapper: this._element, ripple: rippleHTML, styles });\n    this._removeHTMLRipple({ ripple: rippleHTML, duration });\n  }\n  _createHTMLRipple({ wrapper, ripple, styles }) {\n    Object.keys(styles).forEach((property) => ripple.style[property] = styles[property]);\n    ripple.classList.add(CLASSNAME_RIPPLE_WAVE);\n    if (this._options.rippleColor !== \"\") {\n      this._removeOldColorClasses(wrapper);\n      this._addColor(ripple, wrapper);\n    }\n    this._toggleUnbound(wrapper);\n    this._appendRipple(ripple, wrapper);\n  }\n  _removeHTMLRipple({ ripple, duration }) {\n    if (this._rippleTimer) {\n      clearTimeout(this._rippleTimer);\n      this._rippleTimer = null;\n    }\n    this._rippleTimer = setTimeout(() => {\n      if (ripple) {\n        ripple.remove();\n        if (this._element) {\n          SelectorEngine$1.find(`.${CLASSNAME_RIPPLE_WAVE}`, this._element).forEach((rippleEl) => {\n            rippleEl.remove();\n          });\n          if (this._isMinWidthSet) {\n            Manipulator$1.style(this._element, { \"min-width\": \"\" });\n            this._isMinWidthSet = false;\n          }\n          if (this._rippleInSpan && this._element.classList.contains(CLASSNAME_RIPPLE_WRAPPER)) {\n            this._removeWrapperSpan();\n          } else {\n            Manipulator$1.removeClass(this._element, CLASSNAME_RIPPLE);\n          }\n        }\n      }\n    }, duration);\n  }\n  _removeWrapperSpan() {\n    const child = this._element.firstChild;\n    this._element.replaceWith(child);\n    this._element = child;\n    this._element.focus();\n    this._rippleInSpan = false;\n  }\n  _durationToMsNumber(time) {\n    return Number(time.replace(\"ms\", \"\").replace(\"s\", \"000\"));\n  }\n  _getConfig(config = {}) {\n    const dataAttributes = Manipulator$1.getDataAttributes(this._element);\n    config = {\n      ...Default,\n      ...dataAttributes,\n      ...config\n    };\n    typeCheckConfig(NAME$1, config, DefaultType);\n    return config;\n  }\n  _getDiameter({ offsetX, offsetY, height, width }) {\n    const top2 = offsetY <= height / 2;\n    const left2 = offsetX <= width / 2;\n    const pythagorean = (sideA, sideB) => Math.sqrt(sideA ** 2 + sideB ** 2);\n    const positionCenter = offsetY === height / 2 && offsetX === width / 2;\n    const quadrant = {\n      first: top2 === true && left2 === false,\n      second: top2 === true && left2 === true,\n      third: top2 === false && left2 === true,\n      fourth: top2 === false && left2 === false\n    };\n    const getCorner = {\n      topLeft: pythagorean(offsetX, offsetY),\n      topRight: pythagorean(width - offsetX, offsetY),\n      bottomLeft: pythagorean(offsetX, height - offsetY),\n      bottomRight: pythagorean(width - offsetX, height - offsetY)\n    };\n    let diameter = 0;\n    if (positionCenter || quadrant.fourth) {\n      diameter = getCorner.topLeft;\n    } else if (quadrant.third) {\n      diameter = getCorner.topRight;\n    } else if (quadrant.second) {\n      diameter = getCorner.bottomRight;\n    } else if (quadrant.first) {\n      diameter = getCorner.bottomLeft;\n    }\n    return diameter * 2;\n  }\n  _appendRipple(target, parent) {\n    const FIX_ADD_RIPPLE_EFFECT = 50;\n    parent.appendChild(target);\n    setTimeout(() => {\n      Manipulator$1.addClass(target, \"active\");\n    }, FIX_ADD_RIPPLE_EFFECT);\n  }\n  _toggleUnbound(target) {\n    if (this._options.rippleUnbound === true) {\n      Manipulator$1.addClass(target, CLASSNAME_UNBOUND);\n    } else {\n      target.classList.remove(CLASSNAME_UNBOUND);\n    }\n  }\n  _addColor(target, parent) {\n    const IS_BOOTSTRAP_COLOR = BOOTSTRAP_COLORS.find(\n      (color) => color === this._options.rippleColor.toLowerCase()\n    );\n    if (IS_BOOTSTRAP_COLOR) {\n      Manipulator$1.addClass(\n        parent,\n        `${CLASSNAME_RIPPLE}-${this._options.rippleColor.toLowerCase()}`\n      );\n    } else {\n      const rgbValue = this._colorToRGB(this._options.rippleColor).join(\",\");\n      const gradientImage = GRADIENT.split(\"{{color}}\").join(`${rgbValue}`);\n      target.style.backgroundImage = `radial-gradient(circle, ${gradientImage})`;\n    }\n  }\n  _removeOldColorClasses(target) {\n    const REGEXP_CLASS_COLOR = new RegExp(`${CLASSNAME_RIPPLE}-[a-z]+`, \"gi\");\n    const PARENT_CLASSS_COLOR = target.classList.value.match(REGEXP_CLASS_COLOR) || [];\n    PARENT_CLASSS_COLOR.forEach((className) => {\n      target.classList.remove(className);\n    });\n  }\n  _colorToRGB(color) {\n    function hexToRgb(color2) {\n      const HEX_COLOR_LENGTH = 7;\n      const IS_SHORT_HEX = color2.length < HEX_COLOR_LENGTH;\n      if (IS_SHORT_HEX) {\n        color2 = `#${color2[1]}${color2[1]}${color2[2]}${color2[2]}${color2[3]}${color2[3]}`;\n      }\n      return [\n        parseInt(color2.substr(1, 2), 16),\n        parseInt(color2.substr(3, 2), 16),\n        parseInt(color2.substr(5, 2), 16)\n      ];\n    }\n    function namedColorsToRgba(color2) {\n      const tempElem = document.body.appendChild(document.createElement(\"fictum\"));\n      const flag = \"rgb(1, 2, 3)\";\n      tempElem.style.color = flag;\n      if (tempElem.style.color !== flag) {\n        return DEFAULT_RIPPLE_COLOR;\n      }\n      tempElem.style.color = color2;\n      if (tempElem.style.color === flag || tempElem.style.color === \"\") {\n        return DEFAULT_RIPPLE_COLOR;\n      }\n      color2 = getComputedStyle(tempElem).color;\n      document.body.removeChild(tempElem);\n      return color2;\n    }\n    function rgbaToRgb(color2) {\n      color2 = color2.match(/[.\\d]+/g).map((a) => +Number(a));\n      color2.length = 3;\n      return color2;\n    }\n    if (color.toLowerCase() === \"transparent\") {\n      return DEFAULT_RIPPLE_COLOR;\n    }\n    if (color[0] === \"#\") {\n      return hexToRgb(color);\n    }\n    if (color.indexOf(\"rgb\") === -1) {\n      color = namedColorsToRgba(color);\n    }\n    if (color.indexOf(\"rgb\") === 0) {\n      return rgbaToRgb(color);\n    }\n    return DEFAULT_RIPPLE_COLOR;\n  }\n  // Static\n  static autoInitial(instance) {\n    return function(event) {\n      instance._autoInit(event);\n    };\n  }\n  static jQueryInterface(options) {\n    return this.each(function() {\n      const data = Data$1.getData(this, DATA_KEY$1);\n      if (!data) {\n        return new Ripple(this, options);\n      }\n      return null;\n    });\n  }\n}\nconst NAME = \"range\";\nconst DATA_KEY = \"mdb.range\";\nconst CLASSNAME_THUMB = \"thumb\";\nconst CLASSNAME_ACTIVE = \"thumb-active\";\nconst CLASSNAME_THUMB_VALUE = \"thumb-value\";\nconst SELECTOR_THUMB_VALUE = `.${CLASSNAME_THUMB_VALUE}`;\nconst SELECTOR_THUMB = `.${CLASSNAME_THUMB}`;\nclass Range extends BaseComponent2 {\n  constructor(element2) {\n    super(element2);\n    this._initiated = false;\n    this._thumb = null;\n    if (this._element) {\n      this.init();\n      Manipulator$1.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, true);\n      bindCallbackEventsIfNeeded(this.constructor);\n    }\n  }\n  // Getters\n  static get NAME() {\n    return NAME;\n  }\n  get rangeInput() {\n    return SelectorEngine$1.findOne(\"input[type=range]\", this._element);\n  }\n  // Public\n  init() {\n    if (this._initiated) {\n      return;\n    }\n    this._addThumb();\n    this._thumbUpdate();\n    this._handleEvents();\n    this._initiated = true;\n  }\n  dispose() {\n    this._disposeEvents();\n    Manipulator$1.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`);\n    super.dispose();\n  }\n  // Private\n  _addThumb() {\n    const RANGE_THUMB = element(\"span\");\n    Manipulator$1.addClass(RANGE_THUMB, CLASSNAME_THUMB);\n    RANGE_THUMB.innerHTML = '<span class=\"thumb-value\"></span>';\n    this._element.append(RANGE_THUMB);\n    this._thumb = SelectorEngine$1.findOne(SELECTOR_THUMB, this._element);\n  }\n  _handleEvents() {\n    EventHandler$1.on(this.rangeInput, \"mousedown\", () => this._showThumb());\n    EventHandler$1.on(this.rangeInput, \"mouseup\", () => this._hideThumb());\n    EventHandler$1.on(this.rangeInput, \"touchstart\", () => this._showThumb());\n    EventHandler$1.on(this.rangeInput, \"touchend\", () => this._hideThumb());\n    EventHandler$1.on(this.rangeInput, \"input\", () => this._thumbUpdate());\n  }\n  _disposeEvents() {\n    EventHandler$1.off(this.rangeInput, \"mousedown\");\n    EventHandler$1.off(this.rangeInput, \"mouseup\");\n    EventHandler$1.off(this.rangeInput, \"touchstart\");\n    EventHandler$1.off(this.rangeInput, \"touchend\");\n    EventHandler$1.off(this.rangeInput, \"input\");\n  }\n  _showThumb() {\n    Manipulator$1.addClass(this._thumb, CLASSNAME_ACTIVE);\n  }\n  _hideThumb() {\n    Manipulator$1.removeClass(this._thumb, CLASSNAME_ACTIVE);\n  }\n  _thumbUpdate() {\n    const rangeInput = this.rangeInput;\n    const inputValue = rangeInput.value;\n    const minValue = rangeInput.min ? rangeInput.min : 0;\n    const maxValue = rangeInput.max ? rangeInput.max : 100;\n    const thumbValue = SelectorEngine$1.findOne(SELECTOR_THUMB_VALUE, this._thumb);\n    thumbValue.textContent = inputValue;\n    const newValue = Number((inputValue - minValue) * 100 / (maxValue - minValue));\n    Manipulator$1.style(this._thumb, { left: `calc(${newValue}% + (${8 - newValue * 0.15}px))` });\n  }\n  // Static\n  static jQueryInterface(config, options) {\n    return this.each(function() {\n      let data = Data$1.getData(this, DATA_KEY);\n      const _config = typeof config === \"object\" && config;\n      if (!data && /dispose/.test(config)) {\n        return;\n      }\n      if (!data) {\n        data = new Range(this, _config);\n      }\n      if (typeof config === \"string\") {\n        if (typeof data[config] === \"undefined\") {\n          throw new TypeError(`No method named \"${config}\"`);\n        }\n        data[config](options);\n      }\n    });\n  }\n}\nconst callbackInitState = /* @__PURE__ */ new Map();\nconst alertCallback = (component, initSelector) => {\n  const Alert3 = component;\n  if (!callbackInitState.has(component.name)) {\n    enableDismissTrigger(Alert3);\n    callbackInitState.set(component.name, true);\n  }\n  SelectorEngine$1.find(initSelector).forEach((element2) => {\n    return Alert3.getOrCreateInstance(element2);\n  });\n};\nconst buttonCallback = (component, initSelector) => {\n  const Button3 = component;\n  const EVENT_CLICK_DATA_API = `click.bs.${component.name}.data-api`;\n  if (!callbackInitState.has(component.name)) {\n    EventHandler$1.on(document, EVENT_CLICK_DATA_API, initSelector, (event) => {\n      event.preventDefault();\n      const button = event.target.closest(initSelector);\n      const data = Button3.getOrCreateInstance(button);\n      data.toggle();\n    });\n    callbackInitState.set(component.name, true);\n  }\n  SelectorEngine$1.find(initSelector).forEach((element2) => {\n    return Button3.getOrCreateInstance(element2);\n  });\n};\nconst carouselCallback = (component, initSelector) => {\n  if (callbackInitState.has(component.name)) {\n    return;\n  }\n  const EVENT_CLICK_DATA_API = `click.bs.${component.name}.data-api`;\n  const SELECTOR_DATA_SLIDE = \"[data-mdb-slide], [data-mdb-slide-to]\";\n  const CLASS_NAME_CAROUSEL2 = \"carousel\";\n  const Carousel3 = component;\n  const EVENT_LOAD_DATA_API = `load.bs.${component.name}.data-api`;\n  const SELECTOR_DATA_RIDE = initSelector;\n  EventHandler$1.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_SLIDE, function(event) {\n    const target = getElementFromSelector(this);\n    if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL2)) {\n      return;\n    }\n    event.preventDefault();\n    const carousel = Carousel3.getOrCreateInstance(target);\n    const slideIndex = this.getAttribute(\"data-mdb-slide-to\");\n    if (slideIndex) {\n      carousel.to(slideIndex);\n      carousel._maybeEnableCycle();\n      return;\n    }\n    if (Manipulator$1.getDataAttribute(this, \"slide\") === \"next\") {\n      carousel.next();\n      carousel._maybeEnableCycle();\n      return;\n    }\n    carousel.prev();\n    carousel._maybeEnableCycle();\n  });\n  EventHandler$1.on(window, EVENT_LOAD_DATA_API, () => {\n    const carousels = SelectorEngine$1.find(SELECTOR_DATA_RIDE);\n    carousels.forEach((carousel) => {\n      Carousel3.getOrCreateInstance(carousel);\n    });\n  });\n  callbackInitState.set(component.name, true);\n};\nconst collapseCallback = (component, initSelector) => {\n  const EVENT_CLICK_DATA_API = `click.bs.${component.name}.data-api`;\n  const SELECTOR_DATA_TOGGLE2 = initSelector;\n  const Collapse3 = component;\n  if (!callbackInitState.has(component.name)) {\n    EventHandler$1.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE2, function(event) {\n      if (event.target.tagName === \"A\" || event.delegateTarget && event.delegateTarget.tagName === \"A\") {\n        event.preventDefault();\n      }\n      const selector = getSelectorFromElement(this);\n      const selectorElements = SelectorEngine$1.find(selector);\n      selectorElements.forEach((element2) => {\n        Collapse3.getOrCreateInstance(element2, { toggle: false }).toggle();\n      });\n    });\n    callbackInitState.set(component.name, true);\n  }\n  SelectorEngine$1.find(SELECTOR_DATA_TOGGLE2).forEach((el) => {\n    const selector = getSelectorFromElement(el);\n    const selectorElements = SelectorEngine$1.find(selector);\n    selectorElements.forEach((element2) => {\n      Collapse3.getOrCreateInstance(element2, { toggle: false });\n    });\n  });\n};\nconst dropdownCallback = (component, initSelector) => {\n  const EVENT_CLICK_DATA_API = `click.bs.${component.name}.data-api`;\n  const EVENT_KEYDOWN_DATA_API = `keydown.bs.${component.name}.data-api`;\n  const EVENT_KEYUP_DATA_API = `keyup.bs.${component.name}.data-api`;\n  const SELECTOR_MENU2 = \".dropdown-menu\";\n  const SELECTOR_DATA_TOGGLE2 = `[data-mdb-${component.NAME}-initialized]`;\n  const Dropdown3 = component;\n  if (!callbackInitState.has(component.name)) {\n    EventHandler$1.on(\n      document,\n      EVENT_KEYDOWN_DATA_API,\n      SELECTOR_DATA_TOGGLE2,\n      Dropdown3.dataApiKeydownHandler\n    );\n    EventHandler$1.on(\n      document,\n      EVENT_KEYDOWN_DATA_API,\n      SELECTOR_MENU2,\n      Dropdown3.dataApiKeydownHandler\n    );\n    EventHandler$1.on(document, EVENT_CLICK_DATA_API, Dropdown3.clearMenus);\n    EventHandler$1.on(document, EVENT_KEYUP_DATA_API, Dropdown3.clearMenus);\n    EventHandler$1.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE2, function(event) {\n      event.preventDefault();\n      Dropdown3.getOrCreateInstance(this).toggle();\n    });\n  }\n  callbackInitState.set(component.name, true);\n  SelectorEngine$1.find(initSelector).forEach((el) => {\n    Dropdown3.getOrCreateInstance(el);\n  });\n};\nconst inputCallback = (component, initSelector) => {\n  const SELECTOR_DATA_INIT = initSelector;\n  const SELECTOR_OUTLINE_INPUT = `${SELECTOR_DATA_INIT} input`;\n  const SELECTOR_OUTLINE_TEXTAREA = `${SELECTOR_DATA_INIT} textarea`;\n  const Input2 = component;\n  if (!callbackInitState.has(component.name)) {\n    EventHandler$1.on(document, \"focus\", SELECTOR_OUTLINE_INPUT, Input2.activate(new Input2()));\n    EventHandler$1.on(document, \"input\", SELECTOR_OUTLINE_INPUT, Input2.activate(new Input2()));\n    EventHandler$1.on(document, \"blur\", SELECTOR_OUTLINE_INPUT, Input2.deactivate(new Input2()));\n    EventHandler$1.on(document, \"focus\", SELECTOR_OUTLINE_TEXTAREA, Input2.activate(new Input2()));\n    EventHandler$1.on(document, \"input\", SELECTOR_OUTLINE_TEXTAREA, Input2.activate(new Input2()));\n    EventHandler$1.on(document, \"blur\", SELECTOR_OUTLINE_TEXTAREA, Input2.deactivate(new Input2()));\n    EventHandler$1.on(window, \"shown.bs.modal\", (e) => {\n      SelectorEngine$1.find(SELECTOR_OUTLINE_INPUT, e.target).forEach((element2) => {\n        const instance = Input2.getInstance(element2.parentNode);\n        if (!instance) {\n          return;\n        }\n        instance.update();\n      });\n      SelectorEngine$1.find(SELECTOR_OUTLINE_TEXTAREA, e.target).forEach((element2) => {\n        const instance = Input2.getInstance(element2.parentNode);\n        if (!instance) {\n          return;\n        }\n        instance.update();\n      });\n    });\n    EventHandler$1.on(window, \"shown.bs.dropdown\", (e) => {\n      const target = e.target.parentNode.querySelector(\".dropdown-menu\");\n      if (target) {\n        SelectorEngine$1.find(SELECTOR_OUTLINE_INPUT, target).forEach((element2) => {\n          const instance = Input2.getInstance(element2.parentNode);\n          if (!instance) {\n            return;\n          }\n          instance.update();\n        });\n        SelectorEngine$1.find(SELECTOR_OUTLINE_TEXTAREA, target).forEach((element2) => {\n          const instance = Input2.getInstance(element2.parentNode);\n          if (!instance) {\n            return;\n          }\n          instance.update();\n        });\n      }\n    });\n    EventHandler$1.on(window, \"shown.bs.tab\", (e) => {\n      let targetId;\n      if (e.target.href) {\n        targetId = e.target.href.split(\"#\")[1];\n      } else {\n        targetId = Manipulator$1.getDataAttribute(e.target, \"target\").split(\"#\")[1];\n      }\n      const target = SelectorEngine$1.findOne(`#${targetId}`);\n      SelectorEngine$1.find(SELECTOR_OUTLINE_INPUT, target).forEach((element2) => {\n        const instance = Input2.getInstance(element2.parentNode);\n        if (!instance) {\n          return;\n        }\n        instance.update();\n      });\n      SelectorEngine$1.find(SELECTOR_OUTLINE_TEXTAREA, target).forEach((element2) => {\n        const instance = Input2.getInstance(element2.parentNode);\n        if (!instance) {\n          return;\n        }\n        instance.update();\n      });\n    });\n    EventHandler$1.on(window, \"reset\", (e) => {\n      SelectorEngine$1.find(SELECTOR_OUTLINE_INPUT, e.target).forEach((element2) => {\n        const instance = Input2.getInstance(element2.parentNode);\n        if (!instance) {\n          return;\n        }\n        instance.forceInactive();\n      });\n      SelectorEngine$1.find(SELECTOR_OUTLINE_TEXTAREA, e.target).forEach((element2) => {\n        const instance = Input2.getInstance(element2.parentNode);\n        if (!instance) {\n          return;\n        }\n        instance.forceInactive();\n      });\n    });\n    EventHandler$1.on(window, \"onautocomplete\", (e) => {\n      const instance = Input2.getInstance(e.target.parentNode);\n      if (!instance || !e.cancelable) {\n        return;\n      }\n      instance.forceActive();\n    });\n    callbackInitState.set(component.name, true);\n  }\n  SelectorEngine$1.find(SELECTOR_DATA_INIT).map((element2) => Input2.getOrCreateInstance(element2));\n};\nconst modalCallback = (component, initSelector) => {\n  const EVENT_CLICK_DATA_API = `click.bs.${component.name}.data-api`;\n  const OPEN_SELECTOR = \".modal.show\";\n  const Modal3 = component;\n  const EVENT_SHOW2 = `show.bs.${component.name}`;\n  const EVENT_HIDDEN2 = `hidden.bs.${component.name}`;\n  if (!callbackInitState.has(component.name)) {\n    EventHandler$1.on(document, EVENT_CLICK_DATA_API, initSelector, function(event) {\n      const target = getElementFromSelector(this);\n      if ([\"A\", \"AREA\"].includes(this.tagName)) {\n        event.preventDefault();\n      }\n      EventHandler$1.one(target, EVENT_SHOW2, (showEvent) => {\n        if (showEvent.defaultPrevented) {\n          return;\n        }\n        EventHandler$1.one(target, EVENT_HIDDEN2, () => {\n          if (isVisible$1(this)) {\n            this.focus();\n          }\n        });\n      });\n      const alreadyOpenedModals = SelectorEngine$1.find(OPEN_SELECTOR);\n      alreadyOpenedModals.forEach((modal) => {\n        if (!modal.classList.contains(\"modal-non-invasive-show\")) {\n          Modal3.getInstance(modal).hide();\n        }\n      });\n      const data = Modal3.getOrCreateInstance(target);\n      data.toggle(this);\n    });\n    enableDismissTrigger(Modal3);\n    callbackInitState.set(component.name, true);\n  }\n  SelectorEngine$1.find(initSelector).forEach((el) => {\n    const selector = getSelectorFromElement(el);\n    const selectorElement = SelectorEngine$1.findOne(selector);\n    Modal3.getOrCreateInstance(selectorElement);\n  });\n};\nconst offcanvasCallback = (component, initSelector) => {\n  if (callbackInitState.has(component.name)) {\n    return;\n  }\n  const EVENT_CLICK_DATA_API = `click.bs.${component.name}.data-api`;\n  const OPEN_SELECTOR = \".offcanvas.show\";\n  const Offcanvas2 = component;\n  const EVENT_HIDDEN2 = `hidden.bs.${component.name}`;\n  const EVENT_LOAD_DATA_API = `load.bs.${component.name}.data-api`;\n  const EVENT_RESIZE2 = `resize.bs.${component.name}`;\n  EventHandler$1.on(document, EVENT_CLICK_DATA_API, initSelector, function(event) {\n    const target = getElementFromSelector(this);\n    if ([\"A\", \"AREA\"].includes(this.tagName)) {\n      event.preventDefault();\n    }\n    if (isDisabled$1(this)) {\n      return;\n    }\n    EventHandler$1.one(target, EVENT_HIDDEN2, () => {\n      if (isVisible$1(this)) {\n        this.focus();\n      }\n    });\n    const alreadyOpen = SelectorEngine$1.findOne(OPEN_SELECTOR);\n    if (alreadyOpen && alreadyOpen !== target) {\n      Offcanvas2.getInstance(alreadyOpen).hide();\n    }\n    const data = Offcanvas2.getOrCreateInstance(target);\n    data.toggle(this);\n  });\n  EventHandler$1.on(window, EVENT_LOAD_DATA_API, () => {\n    SelectorEngine$1.find(OPEN_SELECTOR).forEach((selector) => {\n      Offcanvas2.getOrCreateInstance(selector).show();\n    });\n  });\n  EventHandler$1.on(window, EVENT_RESIZE2, () => {\n    SelectorEngine$1.find(\"[aria-modal][class*=show][class*=offcanvas-]\").forEach((element2) => {\n      if (getComputedStyle(element2).position !== \"fixed\") {\n        Offcanvas2.getOrCreateInstance(element2).hide();\n      }\n    });\n  });\n  enableDismissTrigger(Offcanvas2);\n  callbackInitState.set(component.name, true);\n};\nconst scrollspyCallback = (component, initSelector) => {\n  if (callbackInitState.has(component.name)) {\n    return;\n  }\n  const EVENT_LOAD_DATA_API = `load.bs.${component.name}.data-api`;\n  const ScrollSpy3 = component;\n  EventHandler$1.on(window, EVENT_LOAD_DATA_API, () => {\n    SelectorEngine$1.find(initSelector).forEach((el) => {\n      ScrollSpy3.getOrCreateInstance(el);\n    });\n  });\n  callbackInitState.set(component.name, true);\n};\nconst tabCallback = (component, initSelector) => {\n  const EVENT_LOAD_DATA_API = `load.bs.${component.name}.data-api`;\n  const EVENT_CLICK_DATA_API = `click.bs.${component.name}.data-api`;\n  const CLASS_NAME_ACTIVE2 = \"active\";\n  const SELECTOR_DATA_TOGGLE_ACTIVE = `.${CLASS_NAME_ACTIVE2}[data-mdb-tab-init], .${CLASS_NAME_ACTIVE2}[data-mdb-pill-init], .${CLASS_NAME_ACTIVE2}[data-mdb-toggle=\"list\"]`;\n  const Tab3 = component;\n  if (!callbackInitState.has(component.name)) {\n    EventHandler$1.on(document, EVENT_CLICK_DATA_API, initSelector, function(event) {\n      if ([\"A\", \"AREA\"].includes(this.tagName)) {\n        event.preventDefault();\n      }\n      if (isDisabled$1(this)) {\n        return;\n      }\n      Tab3.getOrCreateInstance(this).show();\n    });\n    EventHandler$1.on(window, EVENT_LOAD_DATA_API, () => {\n      SelectorEngine$1.find(SELECTOR_DATA_TOGGLE_ACTIVE).forEach((element2) => {\n        Tab3.getOrCreateInstance(element2);\n      });\n    });\n    callbackInitState.set(component.name, true);\n  }\n};\nconst toastCallback = (component, initSelector) => {\n  const Toast3 = component;\n  if (!callbackInitState.has(component.name)) {\n    enableDismissTrigger(Toast3);\n    callbackInitState.set(component.name, true);\n  }\n  SelectorEngine$1.find(initSelector).forEach((element2) => {\n    return Toast3.getOrCreateInstance(element2);\n  });\n};\nconst rippleCallback = (component, initSelector) => {\n  const Ripple2 = component;\n  if (!callbackInitState.has(component.name)) {\n    EventHandler$1.one(document, \"mousedown\", initSelector, Ripple2.autoInitial(new Ripple2()));\n    callbackInitState.set(component.name, true);\n  }\n};\nconst defaultInitSelectors = {\n  // Bootstrap Components\n  alert: {\n    name: \"Alert\",\n    selector: \"[data-mdb-alert-init]\",\n    isToggler: true,\n    callback: alertCallback\n  },\n  button: {\n    name: \"Button\",\n    selector: \"[data-mdb-button-init]\",\n    isToggler: true,\n    callback: buttonCallback\n  },\n  carousel: {\n    name: \"Carousel\",\n    selector: \"[data-mdb-carousel-init]\",\n    isToggler: true,\n    callback: carouselCallback\n  },\n  collapse: {\n    name: \"Collapse\",\n    selector: \"[data-mdb-collapse-init]\",\n    isToggler: true,\n    callback: collapseCallback\n  },\n  dropdown: {\n    name: \"Dropdown\",\n    selector: \"[data-mdb-dropdown-init]\",\n    isToggler: true,\n    callback: dropdownCallback\n  },\n  modal: {\n    name: \"Modal\",\n    selector: \"[data-mdb-modal-init]\",\n    isToggler: true,\n    callback: modalCallback\n  },\n  offcanvas: {\n    name: \"Offcanvas\",\n    selector: \"[data-mdb-offcanvas-init]\",\n    isToggler: true,\n    callback: offcanvasCallback\n  },\n  scrollspy: {\n    name: \"ScrollSpy\",\n    selector: \"[data-mdb-scrollspy-init]\",\n    isToggler: true,\n    callback: scrollspyCallback\n  },\n  tab: {\n    name: \"Tab\",\n    selector: \"[data-mdb-tab-init], [data-mdb-pill-init], [data-mdb-list-init]\",\n    isToggler: true,\n    callback: tabCallback\n  },\n  toast: {\n    name: \"Toast\",\n    selector: \"[data-mdb-toast-init]\",\n    isToggler: true,\n    callback: toastCallback\n  },\n  tooltip: {\n    name: \"Tooltip\",\n    selector: \"[data-mdb-tooltip-init]\",\n    isToggler: false\n  },\n  input: {\n    name: \"Input\",\n    selector: \"[data-mdb-input-init]\",\n    isToggler: true,\n    callback: inputCallback\n  },\n  range: {\n    name: \"Range\",\n    selector: \"[data-mdb-range-init]\",\n    isToggler: false\n  },\n  ripple: {\n    name: \"Ripple\",\n    selector: \"[data-mdb-ripple-init]\",\n    isToggler: true,\n    callback: rippleCallback\n  },\n  popover: {\n    name: \"Popover\",\n    selector: \"[data-mdb-popover-init]\",\n    isToggler: false,\n    callback: rippleCallback\n  }\n};\nconst initMDBInstance = new InitMDB(defaultInitSelectors);\nconst initMDB = initMDBInstance.initMDB;\n\n//# sourceMappingURL=mdb.es.min.js.map\n\n\n//# sourceURL=webpack://ninaverse/./node_modules/mdb-ui-kit/js/mdb.es.min.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./public/js/main.js");
/******/ 	
/******/ })()
;